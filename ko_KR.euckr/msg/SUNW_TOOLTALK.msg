$ $XConsortium: SUNW_TOOLTALK.msg /main/3 1996/07/24 18:57:05 drk $
$quote "
$set 1
3	"%s에서 rpc.ttbdseverd에 대한 clnt_create가 실패했습니다.%s"
4	"오류: %s의 rpc.ttdbserverd가 수행중이지 않습니다."
6	"서버 버전 (%s)이 데이타베이스 표의 버전 (%s)과 일치하지 않습니다.\
버전 %s의 데이타베이스 서버를 수행해 주십시오."
7	"데이타베이스 표 %s:%s을(를) 열려는 시도가 실패했습니다."
14	"이 세션을 알리는 X 루트 윈도우 특성 %s을(를) 삭제할 수 없었습니다."
15	"주소 버전은 %d이지만, %d! (address: <%s>)밖에 인식하지 못합니다."
17	"다음 X 디스플레이 이름을 분석할 수 없었습니다. \"%s\""
18	"내부 오류 %d 때문에 파일 메세지를 \"%s\"의 대기행렬에 넣을 수 없었습니다."
19	"못쓰게 된 세션 <%s>을(를) 파일 \"%s\"의 해당 목록에서 삭제할 수 없었습니다.\
 내부 오류 %d 때문"
20	"무관한 세션 <%s>을(를) 파일 \"%s\"의 해당 목록에서 삭제할 수 없었습니다.\
 내부 오류 %d 때문"
21	"다음 줄에 tttracefile 구문 오류:\n%s"
22	"$%s의 tttracefile을 처리할 수 없었습니다."
23	"실제 UID가 유효 UID와 같지 않으면 추적이 허용되지 않습니다."
24	"수용 요구"
25	"문서가 비었거나 파일이 없습니다."
26	"메세지 ID를 가져올 수 없습니다. tt_message_arg_val()때문에 \작동을 취소할 수 없습니다."
27	"제목을 가져올 수 없습니다. tt_message_arg_val()때문에 \문서에 제목을 달 수 없습니다."
28	"알 수 없는 opnum 오프세트"
$set 2
2	"ptype %s에 대해 구별할 수 없는 서명이 발견되었습니다."
3	"연결 지향 이동이 없습니다."
4	"만기된 메세지를 검색하기 전에 ToolTalk 클라이언트가\ 종료되었습니다."
5	"ToolTalk 클라이언트에 메세지 검색하는 중에 그것에 대한 \연결이 없어졌습니다."
6	"수행중인 또 다른 세션이 있습니다.(host=%s, pid=%d)"
7	"해당 세션에 접속할 수 없습니다.(host=%s, pid=%d) 그것이 손상되었다고 가정합니다.\
.."
8	"알려진 세션 id를 분석할 수 없습니다. 그것을 이 시스템의 것으로 \겹쳐쓰는 중입니다..."
9	"%s은(는) 버전 %d 유형 데이타베이스이며, 이 버전은 버전 %d와(과) \그 이전 버전만을 읽을 수 있습니다."
10	"다음 유형 데이타베이스에서 유형을 해독할 수 없었습니다. %s. 그것이 손상되었을 수 있습니다."
11	"%s을(를) 겹쳐썼습니다."
12	"ToolTalk 서명의 알 수 없는 속성 <%s>을(를) 무시합니다..."
13	"ttce2xdr가 실패했습니다.(status=%d) 클래싱 엔진 \"user\" datab의 \유형이 변환되지 변환되지 않았습니다."
14	"중복 ISAM 레코드"
15	"ISAM 파일이 열리지 않습니다."
16	"잘못된 ISAM 인수"
17	"잘못된 ISAM 키 서술어"
18	"너무 많은 ISAM 파일을 열었습니다."
19	"잘못된 ISAM 파일 형식"
20	"ISAM 비독점 사용"
21	"ISAM 레코드가 잠겼습니다."
22	"ISAM 키가 이미 있습니다."
23	"ISAM 키는 주 키입니다."
24	"ISAM 파일의 끝 또는 시작"
25	"ISAM 레코드가 없습니다."
26	"현재 ISAM 레코드가 없습니다."
27	"ISAM 파일이 잠겼습니다."
28	"ISAM 파일 이름이 너무 깁니다."
29	"ISAM이 메모리를 할당할 수 없습니다."
30	"ISAM RPC 시간 종료"
31	"ISAM TCP/IP 연결이 끊어졌습니다."
32	"ISAM 서버에 연결할 수 없습니다."
33	"ISAM 데이타를 반입할 수 없습니다."
34	"로컬 SAM 데몬이 없습니다."
35	"치명적 ISAM 내부 오류"
36	"ISAM Locale/LANG이 맞지 않습니다."
$set 3
2	"자식(%d)이 신호 %d%s때문에 종료되었습니다."
3	" (코어 덤프)"
4	"자식(%d)이 종료되지 않았거나 신호를 받지 않았습니다."
5	"%m때문에 클라이언트를 가장 크게 만들 수 없습니다."
6	"관리할 대상이 없습니다.  -c, -p, -d, 또는 set $DISPLAY를 사용하십시오."
7	"-S 선택사항을 -c와 함께 사용할 수 없습니다."
8	"자식 ttsession이 상태 %d(으)로 종료되었습니다."
9	"자식 ttsession 신호 %d%s때문에 종료되었습니다."
10	" (코어 덤프)"
11	"자식 ttsession이 마치지 않았거나 신호를 받지 않았습니다."
12	"시작"
13	"유형을 다시 읽었습니다."
14	"유형에 오류; 이전 유형을 유지합니다."
15	"$OPENWINHOME을 설정하지 않았습니다."
16	"\n사용법: ttsession [-a unix|des][-d display][-spStvhNX"
17	"][-c command]\n -c [command]   프로세스 트리 세션을 시작하고\그 안에서 명령을 수행합니다.\n       선택사항이 명령에 전달됩니다.  기본값: $SH\ELL\n -p       프로세스 트리 세션을 시작하고 그 id를 인쇄합니다.\n -d display\
디스플레이에서 X 세션을 시작합니다.\n\n -a unix|des     서버 인증 단계를 설정합니다.\
\n -s	  경고를 출력하지 않습니다.\n -S     배경으로 분기하지 않습니다.\
\n -N	  허용 클라이언트 수를 가장 크게 합니다.\n -t    메세지 추적을 켭니다.\
\n -X	  고정 유형에 대해 XDR 데이타베이스를 사용합니다.(기본값)\n"
18	" -E        고정 유형에 대해 클래싱 엔진을 사용합니다.\n"
19	"\n -v    버전 번호를 출력합니다.\n -h       이 메세지를 출력합니다.\n\n신호\
인터페이스:\n kill -USR1 ttsession_pid   메세지 추적을 바꿉니다.\n kill -\
USR2 ttsession_pid 정적 유형을 다시 읽습니다."
20	"마침"
$set 4
2	"사용법:\ntt_type_comp [-s] [-d db] [-mM] source_file\ntt_type_comp [-s\
] [-d db] -r type ...\n-M  원시 유형을 지정된 데이타베이스로 합칩니다.\
기존 유형을 갱신하지 않습니다.\n-m  합칩니다. 그러나 기존 유형들을 갱신합니다.  기본값\
.\n-r  지정된 데이타베이스에서 원시 유형을 삭제합니다.\n-d db  작용할\
데이타베이스. 다음 중 하나: 사용자, 시스템, 또는 네트워크. 기본값: 사용자\n-G\
ToolTalk 데이타베이스 서버에서 불필요 정보 수집.\n\ntt_type_comp [-s\
E] -p|O|P [-d db]\ntt_type_comp [-s]  -p|O|P compiled_file\n-O \
 stdout에서 읽은 모든 otype들의 이름을 나열\n-P        stdout에서 읽은 모든 ptype의 이름\
나열\n-p   stdout에서 읽은 모든 ToolTalk 유형을 인쇄\
\n-E	XDR 데이타베이스(들) 대신 클래싱 엔진 데이타베이스(들)를 사용\
\n-d db  읽어 온 데이타베이스. 다음 중 하나: 사용자, 시스템, 또는 네트워크. 기본값:\
: all\n\ntt_type_comp [-s] -x [-o compiled_file] source_file\n-x \
source_file (또는 파일이 \"-\"일 경우, stdin)로 부터 유형을\n-o 컴파일한 유형들을\
compiled_file (또는 파일이 \"-\"일 경우, stdout)에 쓰기\n   기본값: source\
_file.xdr, 또는 원시 파일이 stdin\n\ntt_type_comp [-hv]일 경우, \"types.xdr\"\
\n-v	  버전 번호를 출력\n-h  이 메세지를 출력\n-s  모든 상태 메세지를\
출력하지는 않음.\n\n이들 cpp 선택사항은 통과됩니다.\n   \
	-undef -Dname -Idirectory -Uname -Ydirectory"
3	"유형 파일의 의미 오류"
4	"유효한 ToolTalk 유형 파일이 아닙니다."
5	"클래싱 엔진 데이타베이스에서 ToolTalk 유형을 읽을 수 없습니다."
6	"클래싱 엔진 표 합치기는 더 이상 지원되지 않습니다."
7	"%s 데이타베이스의 유형을 읽을 수 없습니다. - 버전이 맞지 않습니다."
8	"%s 데이타베이스의 유형을 읽을 수 없습니다."
9	"$OPENWINHOME을 설정하지 않았습니다."
10	"%s 데이타베이스를 쓰기 위해 초기화할 수 없습니다."
11	"%s에 대한 이전 정의를 삭제할 수 없습니다."
12	"겹쳐쓰는 중입니다."
13	"써넣는 중입니다."
14	"%s에 대한 새 정의를 추가할 수 없었습니다."
15	"%s에 대한 이전 정의를 삭제할 수 없었습니다."
16	"겹쳐쓰는 중입니다."
17	"써넣는 중입니다."
18	"%s에 대한 새 정의를 추가할 수 없었습니다."
19	"컴파일된 유형들의 버전이 맞지 않습니다."
20	"데이타베이스의 유형을 읽을 수 없습니다."
21	"$OPENWINHOME을 설정하지 않았습니다."
22	"%s 데이타베이스의 유형을 읽을 수 없습니다. - 버전이 맞지 않습니다."
23	"%s 데이타베이스의 유형을 읽을 수 없습니다."
24	"$OPENWINHOME을 설정하지 않았습니다."
25	"otype %s을(를) 삭제하는 중입니다.\n"
26	"ptype %s을(를) 삭제하는 중입니다.\n"
27	"출력을 %s에 써넣음\n"
28	"유효하지 않은 데이타베이스: %s"
29	"선택사항 -O -P -m -M -p -r -x 중 하나만을 지정하십시오."
30	"다음 원인때문에 선행 처리가 이루어지지 않았습니다. %s: %s"
31	"otype 상속 주기에 %s이(가) 필요함"
32	"otype %$1s의 조상 %$2s이(가) 없습니다."
33	"ptype %s은(는) 없지만, otype %s에 의해 구현자로 이름 지정되었습니다."
34	"otype %s에 복수 처리기를 정의했습니다."
35	"otype %s에 상속된 서명이 부모 유형에는 없습니다."
36	"두 ptype, %s와(과) %s이(가) 같은 처리기를 가집니다."
37	"otype %$1s의 조상 %$2s이(가) 없습니다."
38	"순환 otype 상속 계층 -\n  {"
39	"otype %s의 정의가 중복됨"
40	"ptype %s의 정의가 중복됨"
$set 5
3	"보안 위반: RPC 호출이 ToolTalk 데이타베이스가 아닌 파일을 열도록 \
요구했습니다."
4	"새 (>= 1.1) rpc.ttdbserverd를 사용한 후에 이전 (<= 1.0.2) rpc.ttdbserverd를\ 사용하여 기록한 모든 데이타는 무시됩니다."
5	"새 (>= 1.1) rpc.ttdbserverd를 사용한 후에 이전 (<= 1.0.2) rpc.ttdbserverd를\ 사용하여 기록한 모든 데이타는 무시됩니다."
6	"rpc.ttdbserverd 버전 (%s)이(가) 데이타베이스 표의 버전 (%s)와(과)\
맞지 않습니다. rpc.ttdbserverd 버전 %s (또는 그 이상\)을 설치해 주십시오"
7	"사용법:\nrpc.ttdbserverd [-S] [-n] [-m DTMOUNTPOINT]\nrpc.ttdbserverd \
[-S] [-v]"
8	"불필요 정보 수집 스레드를 시작할 수 없습니다. thr_create()\n"
9	"불필요 정보 수집에 대해 fork()할 수 없습니다.\n"
$set 6
2	"사용법:\nttdbck [-f file] [-k objkey] [-t type] [-bx] \n[-impa] [-IZ] \
[-F newfilename] [-T newtype] [mountpoints]\n"
3	"ttdbck: 수리 [-FTZ] 선택사항이 지정되면, \n선택 [-fkt] 선택사항 또는 \진단 [-bx] 선택사항을 지정해야 합니다.\n"
4	"컴파일된 유형들의 버전이 맞지 않습니다."
5	"데이타베이스의 유형을 읽을 수 없습니다."
6	"ttdbck: 'ttdbck -I'를 시도해 보십시오.\n"
7	"파일 이름에 의해 선택하십시오: %s\n"
8	"objid 키에 의해 선택하십시오:"
9	"유형에 의해 선택하십시오: %s\n"
10	"진단이 개체들을 잘못 형성했습니다.\n"
11	"진단이 존재하지 않는 개체를 참조합니다.\n"
12	"디스플레이 id\n"
13	"디스플레이 필수 데이타\n"
14	"디스플레이 특성과 값 데이타\n"
15	"검사하기 전에 NetISAM isrepair() 함수를 호출하십시오.\n"
16	"다음 유형으로 설정하여 수리하십시오: %s\n"
17	"삭제하여 수리하십시오.\n"
18	"출력 단게 %d을(를) 오류 정정하십시오.\n"
19	"다음 파일로 설정하여 수리하십시오. %s\n"
20	"오류: spec에 대한 파일이 없습니다.\n"
21	"오류: spec에 대한 파일이 없습니다.\n"
22	"오류: \"%s\"은(는) 설치된 otype이 아닙니다.\n"
23	"오류: spec이 유형 특성에 대해 복수의 값을 가지고 있습니다.\n"
24	"오류: "
25	"ttdbck: 오류가 발견되지 않았습니다.\n"
26	"오류: "
$set 7
2	"사용법: %s {ctx}[fhpPv[v]] [tarfile] pathname ...\n       %s {ctx}fL[h\
pPRv[v]] tttarfile pathname ...\n         %s -v\n          %s -h\n"
3	"\tc       아카이브를 만듭니다.\n\tt       아카이브의 내용을 나열합니다.\n\t\
x	  아카이브에서 추출합니다.\n\tf    다음 인수 <tarfile>을 아카이브로 사용합니다.\
\n\th	  심볼 링크를 따릅니다.\n\tL       tar(1)을 호출하지 않습니다.\n\t\
p	  파일 모드를 보존합니다.\n\tP     (루트가) 오브젝트의 소유자, mod time 등을\
보존하지 않습니다.\n\tR   디렉토리로 재귀하지 않습니다.\n\tv    \
   장황합니다.\n\tvv     아주 장황합니다.\n\t-v   버전 번호를 인쇄하고\
마칩니다.\n\t-h[elp] 이 메세지를 인쇄합니다.\n"
4	"%s: 아카이브 스트림에서 오브젝트 종류를 읽을 수 없습니다.\n"
5	"%s: 아카이브 스트림에서 아카이브 버전을 읽을 수 없습니다.\n"
6	"%s: 아카이브 버전 %d을(를) 발견했지만, 버전 %d이(가) 와야 했습니다.\n"
7	"%s: 아카이브에서 알 수 없는 종류 %d의 오브젝트를 발견했습니다.\n"
8	"%s: 아카이브 스트림에서 오브젝트 종류를 읽을 수 없습니다.\n"
9	"%s: 아카이브 스트림에서 아카이브 버전을 읽을 수 없습니다.\n"
10	"%s: 아카이브 버전 %d을(를) 발견했지만, 버전 %d이(가) 와야 했습니다.\n"
11	"%s: 아카이브에서 알 수 없는 종류 %d의 오브젝트를 발견했습니다.\n"
$set 8
2	"%s: %$2s때문에 %$1s의 ToolTalk 오브젝트를 삭제할 수 없었습니다.\n"
3	"%s: %$3s때문에 \"%$1s\"을(를) \"%$2s\"(으)로 옮길 수 없었습니다.\n"
4	"%s: ~의 ToolTalk 오브젝트를 옮기려 하지 않게 됩니다.\n"
5	"사용법: %s [-] [-fL] path1 path2\n        %s [-] [-fL] path1 [path2 ...\
] dir\n   %s -v\n          %s -h\n"
6	"\t-L     mv(1)을 수행하지 않습니다.\n\t-v      버전 번호를 인쇄하고 \
마칩니다.\n\t-h  이 메세지를 인쇄합니다.\n"
7	"%s: %$2s때문에 %$1s의 ToolTalk 오브젝트를 삭제할 수 없었습니다.\n"
8	"사용법: %s [-] [-%s] %s ...\n     %s -v\n       %s -h\n"
9	"파일"
10	"dir"
11	"\t-L     %s(1)을(를) 수행하지 않습니다.\n\t-v      버전 번호를 인쇄하고\
마칩니다.\n\t-h[elp] 이 메세지를 인쇄합니다."
12	"%s: %s의 ToolTalk 오브젝트를 %s 때문에 삭제할 수 없습니다.\n"
13	"사용법: %s [-pL] file1 file2\n    %s [-prRL] path1 [path2 ...] dir\
\n	  %s -v\n          %s -h\n"
14	"\t-L     cp(1)를 수행하지 않습니다.\n\t-v      버전 번호를 인쇄하고\
마칩니다.\n\t-h  이 메세지를 인쇄합니다.\n"
$set 9
2	"사용법: %s [-0FCa][-o outfile] [-S session | command [options]]\n       \
  %s [-e script | -f scriptfile][-S session | command [options]]\n -0   \
세션의 메세지 추적을 끄거나, 메세지를 추적하지 않고(즉, API 추적만 가지고)\
명령을 수행합니다.\n -F 명령에 의해 분기되거나 ttsession(1)에 의해 세션에서 \
\n	   차후에 시작된 모든 자식들을 따릅니다.\n -C    ToolTalk API\
호출을 추적하지 않습니다.\n -a  추적된 메세지의 모든 속성, 인수, 그리고\
문맥 슬롯을\n      인쇄합니다.  기본값은 한 줄의 요약입니다.\n -e scri\
pt	스크립트에서 tttracefile(4) 설정값을 읽습니다.\n -f 스크립트 파일에서\
tttracefile(4) 설정값을 읽습니다. \"-\": stdin.\n -o outfile   출력합니다. \"-\
\": stdout. 기본값: 세션 출력일 경우는 stdout,\n        명령 추적일 경우는 \
stderr (tttrace의) \n -S session   추적할 세션.  기본값: tt_default_session()을 참조하십시오.\n command 호출하고 추적할 ToolTalk 클라이언트 명령\n"
3	"%s: 세션 <%s>은(는) Session_Trace를 지원하지 않습니다.  kill -USR1을\
대신 사용하십시오. ttsession(1)을 참조하십시오..\n"
$set 10
2	"Tts_address::add()에 전달된 알 수 없는 Tt_address를 무시합니다. \n"
3	"Tts_address::remove()에 전달된 알 수 없는 Tt_address를 무시합니다.\n"
4	"tts_address::tts_set()에 전달된 알 수 없는 주소를 무시합니다.\n"
5	"tts_address::tts_unset()에 전달된 알 수 없는 주소를 무시합니다.\n"
6	"by tts_address::load()가 읽은 알 수 없는 주소를 무시합니다.\n"
7	"Tts_arglist::Tts_arglist - 인수를 읽는 중의 오류 - \n\t"
8	"Tts_arglist::load - 알 수 없는 인수 유형을 발견했습니다. - BARG를 사용합니다.\n"
9	"요약 클래스 Tts_arg::assign (Tt_pattern)을 호출했습니다. - 무시합니다.\n"
10	"요약 클래스 Tts_arg::assign(Tt_message) 호출했습니다. - 무시합니다.\n"
11	"요약 클래스 Tts_arg::generate 호출했습니다. - 무시합니다.\n"
12	"요약 클래스 Tts_arg::save 호출했습니다. - 무시합니다.\n"
13	"요약 클래스 Tts_arg::load 호출했습니다. - 무시합니다.\n"
14	"Tts_arg::mode_to_chars는 유효하지 않은 모드입니다. - TT_INOUT을 사용합니다.\n"
15	"Tts_arg::chars_to_mode는 유효하지 않은 모드입니다. - TT_INOUT을 사용합니다.\n"
16	"Tts_category::set()에 전달된 알 수 없는 Tt_category를 무시합니다.\n"
17	"Tts_category::generate()를 메세지에 대해 호출했습니다. - 무시합니다.\n"
18	"tts_category::load()가 읽은 알 수 없는 범주를 무시합니다.\n"
19	"Tts_class::add()에 전달된 알 수 없는 Tt_class를 무시합니다.\n"
20	"Tts_class::remove()에 전달된 알 수 없는 Tt_class를 무시합니다.\n"
21	"tts_class::tts_set()에 전달된 알 수 없는 클래스를 무시합니다.\n"
22	"tts_class::tts_unset()에 전달된 알 수 없는 클래스를 무시합니다.\n"
23	"tts_class::load()가 읽은 알 수 없는 클래스를 무시합니다.\n"
24	"Tts_connection::universal_callback - 해당 패턴을 형성하는 패턴이 없습니다.\
\n"
25	"Tts_cntxtlist::Tts_cntxtlist - 문맥을 읽는 중의 오류 - \n\t"
26	"Tts_contextlist::load - 알 수 없는 cntxt 유형을 발견했습니다. - BCNTX를 사용합니다.\
T\n"
27	"추상 클래스 Tts_context::assign (Tt_pattern)을 호출했습니다. - 무시합니다.\n"
28	"추상 클래스 Tts_context::assign (Tt_pattern)을 호출했습니다. - 무시합니다.\n"
29	"추상 클래스 Tts_context::generate를 호출했습니다. - 무시합니다.\n"
30	"추상 클래스 Tts_context::save를 호출했습니다. - 무시합니다.\n"
31	"추상 클래스 Tts_context::load를 호출했습니다. - 무시합니다.\n"
32	"Tts_disposition::add()에 전달된 알 수 없는 Tt_disposition을 무시합니다.\n"
33	"Tts_disposition::remove()에 전달된 알 수 없는 Tt_disposition을 무시합니다.\n\
"
34	"tts_disposition::tts_set()에 전달된 알 수 없는 처분을 무시합니다.\n"
35	"tts_disposition::tts_unset()에 전달된 알 수 없는 처분을 무시합니다.\n\
"
36	"tts_disposition::load()가 읽은 알 수 없는 처분을 무시합니다.\n"
37	"%s을(를) 호출했습니다.\n"
38	"ToolTalk 오류: %s\n        출처: 원시 파일 %s 줄 %d\n"
39	"경고: %s\n         출처: 원시 파일 %s 줄 %d\n"
40	" Tts_message_molding::send - 초기화되지 않은 메세지 형성을\
보내려 하고 있습니다.\n"
41	"Tts_scope::add()에 전달된 알 수 없는 Tt_scope를 무시합니다.\n"
42	"Tts_scope::remove()에 전달된 알 수 없는 Tt_scope를 무시합니다.\n"
43	"tts_scope::tts_set()에 전달된 알 수 없는 범위를 무시합니다.\n"
44	"tts_scope::tts_unset()에 전달된 알 수 없는 범위를 무시합니다.\n"
45	"tts_scope::load()가 읽은 알 수 없는 범위를 무시합니다.\n"
46	"Tts_state::add()에 전달된 알 수 없는 Tt_state를 무시합니다.\n"
47	"Tts_state::remove()에 전달된 알 수 없는 Tt_state를 무시합니다.\n"
48	"tts_state::tts_set()에 전달된 알 수 없는 상태를 무시합니다.\n"
49	"tts_state::tts_unset()에 전달된 알 수 없는 상태를 무시합니다.\n"
50	"Tts_state::generate()를 메세지에 대해 호출했습니다. - 무시합니다.\n"
51	"tts_state::load()가 읽은 알 수 없는 상태를 무시합니다.\n"
82	"TTSnoop 도움말을 가져오는 중입니다."
83	"----------------------"
84	"마우스가 해당 단추나 설정값 위에 있을 때"
85	"도움말 키를 누르면 각 단추와 설정값에 대한 도움말을"
86	"볼 수 있습니다. ttsnoop가 사용중인 api 호출이 무엇인지"
87	"알려면, ttsnoop를 호출할 때 -t 스위치를 사용하십시오."
88	""
89	"TTSnoop 사용"
90	"-------------"
91	"메세지를 보려면 설정 시작 선택사항을 선택하십시오."
92	""
93	"메세지 보기를 끝내려면 설정 멈춤 선택사항을 선택하십시오."
94	""
95	"메세지의 유형을 제한하려면:"
96	"         1) 패턴 단추를 선택하십시오"
97	"         2) 관찰할 패턴의 유형을 입력하십시오"
98	"         3) 적용 단추를 선택하십시오"
99	""
100	"표시된 정보를 강조 표시하려면:"
101	"        1) 표시 단추를 선택하십시오"
102	"        2) 강조 표시할 항목들을 표시하십시오"
103	"        3) 적용 단추를 선택하십시오"
104	""
105	"메세지를 보내려면:"
106	"        1) 메세지 단추를 선택하십시오"
107	"        2) 메세지를 편집하십시오"
108	"        3) 메세지 보내기 단추를 선택하십시오"
109	""
110	"메세지를 저장하려면:"
111	"        1) 메세지 단추를 선택하십시오"
112	"        2) 메세지를 편집하십시오"
113	"        3) 메세지 더하기 단추를 선택하십시오"
114	""
115	"저장된 메세지를 보내려면:"
116	"        메세지 보내기 메뉴에서 해당 메세지를 선택하십시오"
117	""
118	"메세지 출력 창을 지우려면 다시입력 단추를 선택하십시오."
119	""
120	"일반적인 ToolTalk 정보"
121	"----------------------------"
122	"ToolTalk를 통해 객체 지향 메세지를"
123	"보내거나 받으려면, 먼저 메세지 전달기로"
124	"프로세스를 등록해야 합니다. 일단 등록하고 나면,"
125	"프로세스는 ToolTalk에 여러 가지 사항을 알려 줍니다."
126	""
127	"        프로세스의 프로세스 유형 (ptype)"
128	"        이것은 메세지 전달기가 이 ptype에서 구현된"
129	"        메세지를 이 프로세스로 지정할 수 있게"
130	"        해 줍니다."
131	""
132	"        프로세스가 참여한 세션."
133	""
134	"        프로세스가 관찰중인 문서."
135	"        이들 문서의 오브젝트에 대한 메세지는"
136	"        장차 그 프로세스로 경로 지정될 수"
137	"        있습니다."
138	""
139	"이러한 등록을 하고 나면 대개 생성된 패턴이"
140	"수정됩니다. 패턴 조작 API 호출을 사용하여"
141	"객체 지향 메세지를 관찰하거나"
142	"처리할 수 있지만, 여기서 설명하는"
143	"방법은 유형 정의에 선언된 정보를"
144	"이용하기 때문에 훨씬"
145	"간단합니다."
146	""
147	"tt_session_join를 사용하여 세션의 일부로 됩니다."
148	"결합할 때는 결합할 세션의 세션 id를"
149	"제공해야 합니다."
150	""
151	"사용중인 도구에 더 이상 ToolTalk 서비스가 필요하지 않으면,"
152	"tt_session_quit으로 세션을 마치십시오."
153	""
154	"사용중인 도구는 파일을 로드할 때 tt_file_join()을"
155	"호출하여 해당 파일에 관심 있는 프로세스"
156	"집합을 결합합니다. 이 파일을 다 사용했으면,"
157	"tt_file_quit()을 호출하여 해당 집합을"
158	"마치십시오. 일부 도구는 한 번에 여러 파일을 열 수 있습니다."
159	"다른 도구들은 한 번에 한 파일만을 열 수 있습니다."
160	"TTSnoop 사용"
161	"------------"
162	"메세지를 보려면 설정 시작 선택사항을 선택하십시오."
163	"메세지 보기를 끝내려면 설정 멈춤 선택사항을 선택하십시오."
164	""
165	"메세지의 유형을 제한하려면:"
166	"          1) 패턴 단추를 선택하십시오"
167	"          2) 관찰할 패턴의 유형을 입력하십시오"
168	"          3) 적용 단추를 선택하십시오"
169	""
170	"표시된 정보를 강조 표시하려면:"
171	"          1) 표시 단추를 선택하십시오"
172	"          2) 강조 표시할 항목들을 표시하십시오"
173	"          3) 적용 단추를 선택하십시오"
174	""
175	"메세지를 보내려면:"
176	"          1) 메세지 단추를 선택하십시오"
177	"          2) 메세지를 편집하십시오"
178	"          3) 메세지 보내기 단추를 선택하십시오"
179	""
180	"메세지를 저장하려면:"
181	"          1) 메세지 단추를 선택하십시오"
182	"          2) 메세지를 편집하십시오"
183	"          3) 메세지 더하기 단추를 선택하십시오"
184	""
185	"저장된 메세지를 보내려면:"
186	"        메세지 보내기 메뉴에서 해당 메세지를 선택하십시오"
187	""
188	"메세지 출력 창을 지우려면 다시입력 단추를 선택하십시오."
189	""
190	"일반적인 ToolTalk 정보"
191	"----------------------"
192	"ToolTalk를 통해 객체 지향 메세지를 보내거나 받으려면,"
193	"먼저 메세지 전달기로 프로세스를 등록해야 합니다. 일단 등록하고 나면,"
194	"프로세스는 ToolTalk에 여러 가지 사항을 알려 줍니다."
195	""
196	"          프로세스의 프로세스 유형 (ptype). 이것은 메세지 전달기가"
197	"          이 ptype에서 구현된 메세지를 이 프로세스로 지정할 수 있게"
198	"          해 줍니다."
199	""
200	"          프로세스가 참여한 세션"
201	""
202	"          프로세스가 관찰중인 문서. 이들 문서의 오브젝트에"
203	"          대한 메세지는 장차 그 프로세스로 경로 지정될 수"
204	"          있습니다."
205	""
206	"이러한 등록을 하고 나면 대개 생성된 패턴이 수정됩니다."
207	"패턴 조작 API 호출을 사용하여 객체 지향 메세지를"
208	"관찰하거나 처리할 수 있지만, 여기서 설명하는"
209	"방법은 유형 정의에 선언된 정보를 이용하기 때문에"
210	"훨씬 짧습니다."
211	""
212	"tt_session_join를 사용하여 세션의 일부로 됩니다. 결합할 때는"
213	"결합할 세션의 세션 id를 제공해야 합니다."
214	""
215	"사용중인 도구에 더 이상 ToolTalk 서비스가 필요하지 않으면,"
216	"tt_session_quit으로 세션을 마치십시오."
217	""
218	"사용중인 도구는 파일을 로드할 때 tt_file_join()을 호출하여"
219	"해당 파일의 관심 프로세스 집합을 결합합니다. 이 파일을 "
220	"다 사용했으면, tt_file_quit()을 호출하여 해당 집합을 마치십시오."
221	"일부 도구는 한 번에 여러 파일을 열 수 있습니다. 다른 도구들은"
222	"한 번에 한 파일만을 열 수 있습니다."
223	"메세지 받기와 표시를 시작하거나 멈추십시오."
224	"메세지 창을 지우십시오."
225	"디스플레이"
226	"----------"
227	"사용중인 프로세스에 대한 메세지가 도착하면, 파일 기술어가"
228	"활동합니다. 사용중인 도구의 특별한 구조에 따라,"
229	"파일 기술어가 활동할 때 창 시스템 툴 키트가 콜백을"
230	"호출하도록 조정하거나, 또는 select(3) 호출에 여러 파일"
231	"기술어를 차단하는 파일 기술어를 포함시킬 수 있습니다."
232	"어느 경우든 파일 기술어가 활동한 후,"
233	"tt_message_receive()를 호출하여 수신 메세지가 담긴 메세지를"
234	"처리합니다. tt_message_*()를 사용하면 메세지의 속성을"
235	"검토하여 사용자가 취해야 할 조치를 판단할 수 있습니다."
236	"핸들들을 비교하거나, tt_message_user_set() 호출로 사용중인"
237	"응용프로그램에 의미가 있는 정보를 넣거나,"
238	"tt_message_callback_add 및 tt_pattern_callback_add 호출로"
239	"메세지와 패턴에 특정 콜백을 넣으면, 자신이 보낸"
240	"메세지에 대한 응답을 인식할 수 있습니다."
241	"메세지"
242	"------"
243	"메세지를 보내려면, 먼저 새 메세지를 할당하고, 적절한 정보를"
244	"기입한 후, 그것을 보냅니다. 모든 응답은 같은 메세지에 나타나게 됩니다."
245	"메세지를 다 처리했으면, 해당 메세지에 사용한 기억장치를 해제하십시오."
246	"(값을 되돌려 주는 요구에 대해서는 필요한 복귀값이 복사된 후에 기억장치를"
247	"해제하십시오. 단순히 알리는 경우라면, 메세지를 보낸 직후라도 좋습니다.)"
248	""
249	"새 메세지를 할당하려면, tt_message_create()를 사용하십시오. 그것은"
250	"\"handle\" 또는 \"opaque pointer\"를 해당 메세지에 되돌려줍니다. 차후의"
251	"호출에서 이 메세지를 참조하려면 이 핸들을 사용하십시오."
252	""
253	"메세지 정보를 기입하려면, tt_message_*_set() 호출을 사용하십시오."
254	"각 메세지 속성마다 다음 중 하나가 있습니다."
255	""
256	"클래스, 주소, OP 및 Args를 설정해야 합니다."
257	""
258	"tt_message_send()로 메세지를 보내십시오."
259	"패턴"
260	"----"
261	"메세지는 송신 프로세스에 의해 특정 수신기로 명확하게"
262	"지정되므로, \"pattern matching\" 방법을 사용하여 수신기를"
263	"결정합니다. 도구들은 관심있는 메세지의 설명을 등록하며"
264	"ToolTalk는 이들 설명을 사용하여 메세지의 경로 지정을"
265	"추측합니다. 각 패턴 세트는 도구가 처리하려는 메세지와"
266	"도구가 관찰하려는 메세지를 설명하기 위해 유지됩니다."
267	"메세지를 받으려는 도구들은 수행 시간에 동적으로 또는"
268	"설치 시간에 정적으로 관심 사항을 선언합니다."
269	"동적 등록은 모든 메세지의 비교 기준이 되는 패턴의 집합으로"
270	"구성됩니다. 메세지가 패턴과 맞으면, 해당 패턴을 등록한"
271	"도구가 메세지를 받을 자격을 갖게 됩니다."
272	""
273	"ToolTalk를 통해 절차적 메세지를 받으려면, 먼저 메세지 전달기로"
274	"프로세스를 등록해야 합니다. 이렇게 등록하고 나면, 해당 프로세스가"
275	"ToolTalk에 패턴을 주게 됩니다. 이때 ToolTalk는 그 패턴에 맞는 메세지를"
276	"프로세스에 전달합니다. 패턴을 다음 두 가지 방법으로 만들 수 있습니다."
277	""
278	"정적으로. ptype을 통해. 프로세스는 메세지 전달기에 자체의 ptype을"
279	"선언할 수 있습니다. 이때 ToolTalk는 해당 ptype의 각 서명으로부터 패턴을"
280	"생성합니다. 이렇게 생성된 패턴은 객체 지향 메세지 전달에서와 같이"
281	"세션과 파일을 결합하고 종료함으로서 수정할 수 있습니다."
282	""
283	"동적으로. 프로세스는 \"실행중에\" 패턴을 만들어 ToolTalk에 등록할"
284	"수 있습니다. 이 기능을 사용한 대표적인 예로는 지나간 모든 메세지를"
285	"단순히 보기만 하고 창에 표시해 주는 메세지 기록 유틸리티가"
286	"있습니다. 그러한 유틸리티는 메세지 프로토콜을 오류 정정할 때"
287	"유용합니다."
288	""
289	"이 응용프로그램은 동적 패턴만을 사용합니다."
290	""
291	"패턴을 등록하려면, 먼저 새 패턴을 할당하고, 적절한"
292	"정보를 기입한 후, 등록하십시오. 패턴의 처리를 마치면"
293	"(더 이상 해당 패턴과 맞는 메세지에 관심이 없게 된 후에만),"
294	"해당 패턴에 대한 기억장치를 해제하십시오."
295	""
296	"새 패턴을 할당하려면, tt_pattern_create()를 사용하십시오. 그것은"
297	"\"handle\" 또는 \"opaque pointer\"를 패턴에 되돌려줍니다. 차후의"
298	"호출에서 이 패턴을 참조하려면 이 핸들을 사용하십시오."
299	""
300	"정보를 패턴에 기입하려면, tt_pattern_*_add() 호출을 사용하십시오."
301	"각 패턴 속성마다 다음 중 하나가 있습니다. 패턴의"
302	"각 속성에 대해 복수의 값을 제공할 수 있습니다. 패턴 속성은"
303	"패턴의 값 중 어느 하나가 메세지의 값과 맞으면 메세지"
304	"속성과 맞는 것입니다."
305	""
306	"이 응용프로그램은 복수의 속성에 대해 비독점 설정값과 쉼표로 구분되는"
307	"값을 사용합니다."
308	""
309	"특정 속성과 관계없이 메세지를 일치시키려면,"
310	"패턴에서 속성을 생략하기만 하면 됩니다."
311	""
312	"패턴 속성을 지정하지 않으면, ToolTalk 서비스는 메세지 속성을"
313	"맞는 속성으로 계산합니다. 사용자는 패턴 속성을 적게 지정하면 할수록"
314	"더 많은 메세지를 받을 자격을 갖게 됩니다."
315	""
316	"한 패턴 속성에 대해 복수의 값이 지정되더라도, 그 값들 중 하나는"
317	"반드시 메세지 속성과 맞아야 합니다. 맞는 값이 없으면,"
318	"ToolTalk 서비스는 사용중인 응용프로그램을 수신기로 가정하지 않습니다."
319	""
320	"속성 범주와 범위는 반드시 제공해야 합니다."
321	""
322	"패턴이 끝나면, tt_pattern_register()로 해당 패턴을 등록한 후,"
323	"필요하면 적용 단추를 선택하여 세션과 파일을"
324	"결합하십시오."
325	""
326	"파일과 세션을 결합했을 때 1차적인 효과는 현재 등록된 패턴을"
327	"갱신하는 것이므로, 결합한 후에 등록된 패턴은 갱신되지"
328	"않습니다. 따라서 결합하기 전에 모든 패턴을 등록하거나,"
329	"새 패턴을 등록한 후에 다시 결합해야 합니다. 이것은"
330	"ptype들을 결합하여 자동으로 등록된 패턴에도 적용됩니다."
331	"메세지 창을 통해 메세지를 추가하면, 이 단추에 붙은 메뉴가"
332	"커집니다. 메세지를 선택하면 보낼 수 있습니다."
333	"주소:"
334	"많은 유형의 도구가 있고 사용자마다 서로 다른 시기에"
335	"서로 다른 도구 집합을 사용하므로, 메세지의 송신자가"
336	"정확한 메세지 수신자를 구별하는 것은 불가능할 때가 많습니다."
337	"그보다는, 송신자가 메세지의 의미를 지정하는 작동 이름을 주고"
338	"메세지가 지정되는 오브젝트 또는 오브젝트 유형(otype)을 주는 것이"
339	"더 현실적입니다."
340	""
341	"객체 지향 메세지에 대해서는 오브젝트와 otype을 사용하십시오. 주소가"
342	"처리기라면, 그 처리기를 지정하십시오."
343	""
344	"          TT_PROCEDURE: Op와 Args가 제공됩니다."
345	""
346	"          TT_OBJECT:    오브젝트, Op, 그리고 Args가 제공됩니다."
347	""
348	"          TT_HANDLER:   처리기, Op, 그리고 Args가 제공됩니다."
349	""
350	"          TT_OTYPE:     Otype, Op, 그리고 Args가 제공됩니다."
351	"처리기:  "
352	"처리기의 정확한 프로세스 id를 알고 있다면, 메세지를 직접 그것에"
353	"주소 지정할 수 있습니다. 이와 같이 보편적인 방법은 프로세스가 일반적인"
354	"요구를 하고 나서 응답의 처리기 속성을 선택함으로써"
355	"같은 처리기에 메세지를 더 지정하기 위한 것입니다. 이렇게 하면"
356	"프로세스들이 방송 메세지 전달을 통해 만나서 대화로 갈 수"
357	"있게 됩니다."
358	"Handler_Ptype:"
359	"메세지를 처리하게 될 프로세스의 유형을 알고 있다면, 기입하십시오."
360	"ptype 정의를 살펴보고 프로토콜의 자세한 사항을 알아내면 ptype을"
361	"알 수 있습니다."
362	"오브젝트:"
363	"메세지가 보내질 오브젝트의 objid를 기입하십시오."
364	"OType:"
365	"오브젝트의 유형."
366	"Op:"
367	"알림 또는 있었던 요구를 설명하는 작동에 기입하십시오."
368	"otype 정의에서 목표 오브젝트를 살펴보고 작동 이름을"
369	"결정하십시오."
370	"Opnum:"
371	"작동 번호. 이것은 오버로드된 작동들(이름은 같지만"
372	"인수 유형이 서로 다른 작동들)을 구분하고"
373	"클라이언트의 \"내부\" 작업 할당 (주어진 메세지에 알맞은"
374	"내부 절차를 호출)을 단순화하기 위해 사용됩니다."
375	"범위:"
376	"메세지가 프로세스에 바람직한 것과 같은 세션의 다른 프로세스에서 나온 것이면,"
377	"범위 세션을 사용하십시오. 메세지가 바람직한 파일에 관한 것이면, 범위 파일을"
378	"사용하십시오."
379	""
380	"        TT_SESSION:          사용중인 세션의 다른 프로세스로부터 메세지를"
381	"                             받습니다."
382	""
383	"        TT_FILE:             결합된 파일에 관한 메세지를 받습니다."
384	""
385	"        TT_BOTH:             파일과 세션 둘 다에 관한 메세지를"
386	"                             받습니다."
387	""
388	"        TT_FILE_IN_SESSION:  이 세션내에서 결합된 파일에 대한 메세지를"
389	"                             받습니다."
390	"세션:"
391	"범위 세션에 대해서는 해당 세션을 지정하십시오. (기본적으로,"
392	"tt_default_session()임)"
393	"파일:"
394	"파일 범위에 대해서는 해당 파일의 이름을 지정하십시오."
395	"범주:"
396	"단순히 메세지를 보기만 하려면 범주 보기를 사용하십시오; 메세지 고유의"
397	"처리기이려면 범주 핸들을 사용하십시오."
398	""
399	"    TT_OBSERVE: 프로세스 보기는 메세지 자체 정보의 복사본을 가져오기만"
400	"                  합니다. 메세지를 볼 수 있는 프로세스 수에는 제한이"
401	"                  없습니다. 메세지가 요구이더라도,"
402	"                  관찰자는 송신자에 값을 되돌려 주지 않아도 됩니다."
403	"                  관찰자가 취한 활동은 기본적인 도구 데이타의"
404	"                  대화식 표시에만 영향을 줍니다."
405	""
406	"    TT_HANDLE:  프로세스 처리는 사실 메세지에 기초한 활동을 수행합니다."
407	"                  주어진 메세지를 한 프로세스만이 처리합니다."
408	"                  메세지가 요구이면, 처리 프로세스는"
409	"                  값을 되돌려주는 프로세스입니다."
410	"                  일반적으로, 처리기가 취한 활동은 해당 도구의 데이타를"
411	"                  계속 저장하는 표시에 영향을 줍니다."
412	"클래스:"
413	"값을 되돌려주는 메세지, 또는 메세지가 처리되거나 대기행렬에 놓이는 시기"
414	"또는 프로세스가 해당 요구를 처리하기 시작하는 시기를 사용자에게 알려주는"
415	"피드백을 원하는 경우 클래스 요구를 사용하십시오. 다른 이벤트의 프로세스를"
416	"알려 주기만 하는 메세지에 대해서는 클래스 알림을 사용하십시오."
417	""
418	"    TT_NOTICE:   알림은 다른 도구에 일부 이벤트가 발생했음을 알리는"
419	"                   메세지입니다. 알림을 보내는 도구들은 응답을 기대하지"
420	"                   않습니다. 송신자는 일어나고 있는 일을 다른 도구들에"
421	"                   알려 줄 뿐입니다."
422	""
423	"       TT_REQUEST: 요구는 또 다른 도구가 활동을 수행하게 하는 메세지입니다."
424	"                   항상 그런 것은 아니지만, 요구 도구는 일부 값이"
425	"                   되돌려지기를 기대할 때가 많습니다. 이 값은"
426	"                   요구에 대한 응답으로 되돌려집니다. 값이 되돌려지지"
427	"                   않더라도, 해당 요구를 처리하는 도구는 성공 또는"
428	"                   실패를 알리는 응답을 보냅니다."
429	"처분:"
430	"수행중인 프로세스가 메세지를 처리할 수 없을 때 취할 활동을"
431	"지정하십시오. Handler_Ptype의 프로세스가 등록될 때까지 메세지를 대기행렬에"
432	"두어야 한다면 대기행렬에 넣으십시오. Handler_Ptype의 프로세스가 시작되어야"
433	"한다면 시작하십시오."
434	""
435	"    TT_QUEUE: 알맞은 ptype이 메세지를 받을 때까지 메세지를"
436	"                대기행렬에 넣으십시오."
437	""
438	"    TT_START: 수행중인 것이 없다면, 알맞은 ptype의 프로세스를"
439	"                시작해 보십시오."
440	""
441	"Tt_disposition 값을 서로 더할 수 있으므로, TT_QUEUE+TT_START는"
442	"메세지를 대기행렬에 넣음과 동시에 프로세스를 시작한다는 뜻입니다."
443	"이것은 시작이 실패(또는 사용자가 거부)할 수 있기 때문에"
444	"자격있는 프로세스가 시작하자마자 메세지가 처리하려 할 때"
445	"쓸모가 있습니다."
446	"상태:"
447	"메세지의 상태 속성에 대한 값. 예상 값과 그 의미는"
448	"다음과 같습니다."
449	""
450	"    TT_CREATED:  메세지가 만들어졌지만 아직 보내지지 않았습니다. 메세지의"
451	"                   송신자만이 이 상태의 메세지를 보게 됩니다."
452	""
453	"    TT_SENT:   메세지가 보내졌지만 아직 처리되지 않았습니다."
454	""
455	"    TT_HANDLED:  메세지가 처리되었으며, 복귀값이 유효합니다."
456	""
457	"    TT_FAILED:   메세지를 처리기에 전달할 수 없었습니다."
458	""
459	"    TT_QUEUED:   메세지를 나중에 전달하기 위해 대기행렬에 넣었습니다."
460	""
461	"    TT_STARTED:  프로세스를 시작하여 메세지를 처리하려 하는 중입니다."
462	""
463	"    TT_REJECTED: 메세지가 예상 처리기에서 거부되었습니다."
464	"                   이 상태는 거부한 프로세스에서만 보입니다."
465	"                   ToolTalk는 이 메세지를 또 다른 예상 핸들러에 전달하기"
466	"                   전에 상태를 다시 TT_SENT로 바꿉니다."
467	"상태:"
468	"응답자가 되돌려준 메세지의 결과를 나타내는 고유 번호"
469	"이 번호는 TT_ERR_LAST (2047)보다 커야 합니다."
470	"상태 문자열:"
471	"메세지의 상태를 설명하는 문자"
472	"송신자:"
473	"메세지를 보낸 프로세스를 구분합니다."
474	"송신자 ptype:"
475	"메세지를 보낸 프로세스의 ptype."
476	"Uid:"
477	"메세지를 보낸 프로세스의 유효 사용자 구별자."
478	"Gid:"
479	"메세지를 보낸 프로세스의 유효 그룹 구별자."
480	"모드:"
481	"메세지 인수의 모드를 지정합니다. 예상 값과 그 의미는"
482	"다음과 같습니다."
483	""
484	"    TT_IN:    인수는 송신자가 써넣으며 처리기와"
485	"                모든 관찰자가 읽습니다."
486	""
487	"    TT_OUT:   인수는 처리기가 써넣으며 송신자와"
488	"                모든 응답 관찰자가 읽습니다."
489	""
490	"    TT_INOUT: 인수는 송신자와 핸들러와 모든 관찰자가"
491	"                써넣고 읽습니다."
492	"유형:"
493	"유형을 나타내는 문자열. 개발자는 나름대로 값을 만들 수 있지만,"
494	"일반적인 값은 \"String\"과 \"int\"입니다."
495	"값:"
496	"유형에 따른 값의 실제 데이타."
497	"적용 단추를 누르면, 받은 각 메세지에 대해"
498	"지정된 설정값이 표시됩니다."
499	"표시 값을 누르면, 그것은 마지막 적용 또는 초기값 중"
500	"최근의 것의 상태로 초기화됩니다."
501	"받기 문맥 편집:"
502	"받으려는 문맥을 추가하거나, 삭제하거나, 바꾸십시오."
503	"패턴 맞추기"
504	"-----------"
505	"송신 프로세스는 메세지를 특정 수신기로 명확하게 지정하지"
506	"않으므로, \"패턴 맞추기\" 방법을 사용하여 수신기를"
507	"결정합니다. 도구들은 관심있는 메세지의 설명을"
508	"등록하며, ToolTalk는 이들 설명을 사용하여 메세지의 경로 지정을"
509	"추측합니다. 각 패턴 세트는 도구가 처리하려는 메세지와"
510	"도구가 관찰하려는 메세지를 설명하기 위해"
511	"유지됩니다. 메세지를 받으려는 도구들은 수행 시간에 동적으로 또는"
512	"설치 시간에 정적으로 관심 사항을 선언합니다."
513	"동적 등록은 모든 메세지의 비교 기준이 되는"
514	"패턴의 집합으로 구성됩니다. 메세지가 패턴과 맞으면,"
515	"해당 패턴을 등록한 도구가 메세지를 받을 "
516	"자격을 갖게 됩니다."
517	""
518	"ToolTalk를 통해 절차적 메세지를 받으려면, 먼저 메세지 전달기로"
519	"프로세스를 등록해야 합니다. 이렇게 등록하고 나면, 해당 프로세스가"
520	"ToolTalk에 패턴을 주게 됩니다. 이때 ToolTalk는 그 패턴에 맞는 메세지를"
521	"프로세스에 전달합니다. 패턴을 다음 두 가지 방법으로 만들 수 있습니다."
522	""
523	"정적으로. ptype을 통해. 프로세스는 메세지 전달기에 자체의 ptype을"
524	"선언할 수 있습니다. 이때 ToolTalk는 해당 ptype의 각 서명으로부터 패턴을"
525	"생성합니다. 이렇게 생성된 패턴은 객체 지향 메세지 전달에서와 같이"
526	"세션과 파일을 결합하고 종료함으로서 수정할 수 있습니다."
527	""
528	"동적으로. 프로세스는 \"실행중에\" 패턴을 만들어 ToolTalk에 등록할"
529	"수 있습니다. 이 기능을 사용한 대표적인 예로는 지나간 모든 메세지를"
530	"단순히 보기만 하고 창에 표시해 주는 메세지 기록 유틸리티가"
531	"있습니다. 그러한 유틸리티는 메세지 프로토콜을 오류 정정할 때"
532	"쓸모가 있습니다."
533	""
534	"이 응용프로그램은 동적 패턴만을 사용합니다."
535	""
536	"패턴을 등록하려면, 먼저 새 패턴을 할당하고, 적절한"
537	"정보를 기입한 후, 등록하십시오. 패턴의 처리를 마치면"
538	"(더 이상 해당 패턴과 맞는 메세지에 관심이 없게 된 후에만),"
539	"해당 패턴에 대한 기억장치를 해제하십시오."
540	""
541	"새 패턴을 할당하려면, tt_pattern_create()를 사용하십시오. 그것은"
542	"\"handle\" 또는 \"opaque pointer\"를 패턴에 되돌려줍니다. 차후의"
543	"호출에서 이 패턴을 참조하려면 이 처리를 사용하십시오."
544	""
545	"정보를 기입하려면, tt_pattern_*_add() 호출을 사용하십시오."
546	"각 패턴 속성마다 다음 중 하나가 있게 됩니다. 패턴의"
547	"각 속성에 대해 복수의 값을 제공할 수 있습니다. 패턴 속성은"
548	"패턴의 값 중 어느 하나가 메세지의 값과 맞으면 메세지"
549	"속성과 맞는 것입니다."
550	""
551	"이 응용프로그램은 복수의 속성에 대해 비독점 설정값과 쉼표로 구분되는"
552	"값을 사용합니다."
553	""
554	"특정 속성과 관계없이 메세지를 일치시키려면,"
555	"패턴에서 속성을 생략하기만 하면 됩니다."
556	""
557	"패턴 속성을 지정하지 않으면, ToolTalk 서비스는 메세지 속성을"
558	"맞는 속성으로 계산합니다. 사용자는 패턴 속성을 적게 지정하면 할수록"
559	"더 많은 메세지를 받을 자격을 갖게 됩니다."
560	""
561	"한 패턴 속성에 대해 복수의 값이 지정되하더라도, 그 값들 중 하나는"
562	"반드시 메세지 속성과 맞아야 합니다. 맞는 값이 하나도 없으면,"
563	"ToolTalk 서비스는 사용중인 응용프로그램을 수신기로 가정합니다."
564	""
565	"속성 범주와 범위는 반드시 제공해야 합니다."
566	""
567	"패턴이 끝나면, tt_pattern_register()로 해당 패턴을 등록한 후,"
568	"필요하면 적용 단추를 선택하여 세션과 파일을"
569	"결합하십시오."
570	""
571	"파일과 세션을 결합했을 때 1차적인 효과는 현재 등록된 패턴을"
572	"갱신하는 것이므로, 결합한 후에 등록된 패턴은 갱신되지"
573	"않습니다. 따라서 결합하기 전에 모든 패턴을 등록하거나,"
574	"새 패턴을 등록한 후에 다시 결합해야 합니다. 이것은"
575	"ptype들을 결합하여 자동으로 등록된 패턴에도"
576	적용됩니다.
577	"주소"
578	"많은 유형의 도구가 있고 사용자마다 서로 다른 시기에"
579	"서로 다른 도구 집합을 사용하므로, 메세지의 송신자가"
580	"정확한 메세지 수신자를 구별하는 것은 불가능할 때가 많습니다."
581	"그보다는, 송신자가 메세지의 의미를 지정하는 작동 이름을 주고"
582	"메세지가 지정되는 오브젝트 또는 오브젝트 유형(otype)을 주는 것이"
583	"더 현실적입니다."
584	""
585	"객체 지향 메세지에 대해서는 오브젝트와 otype을 사용하십시오. 주소가"
586	"처리기라면, 그 처리기를 지정하십시오."
587	""
588	"    TT_PROCEDURE: Op와 Args가 제공됩니다."
589	""
590	"    TT_OBJECT:    오브젝트, Op, 그리고 Args가 제공됩니다."
591	""
592	"    TT_HANDLER:   처리기, Op, 그리고 Args가 제공됩니다."
593	""
594	"    TT_OTYPE:  Otype, Op, 그리고 Args가 제공됩니다."
595	"오브젝트:"
596	"메세지가 보내질 오브젝트의 objid를 기입하십시오."
597	"오브젝트 유형:"
598	"오브젝트의 유형."
599	"Op:"
600	"알림 또는 있었던 요구를 설명하는 작동에 기입하십시오."
601	"otype 정의에서 목표 오브젝트를 살펴보고 작동 이름을"
602	"결정하십시오."
603	"범위:"
604	"메세지가 프로세스에 바람직한 것과 같은 세션의 다른 프로세스에서 나온 것이면,"
605	"범위 세션을 사용하십시오; 메세지가 바람직한 파일에 관한 것이면, 범위 파일을"
606	"사용하십시오."
607	""
608	"    TT_SESSION:             사용중인 세션의 다른 프로세스로부터 메세지를"
609	"                           받습니다."
610	""
611	"    TT_FILE:           결합된 파일에 관한 메세지를 받습니다."
612	""
613	"    TT_BOTH:           파일과 세션 둘 다에 관한 메세지를 받습니다."
614	""
615	"    TT_FILE_IN_SESSION:  이 세션중에 결합된 파일에 대한 메세지를"
616	"                           받습니다."
617	"파일:"
618	"파일 범위에 대해서는 파일의 이름을 지정하십시오."
619	"세션:"
620	"범위 세션에 대해서는 해당 세션을 지정하십시오. (기본적으로,"
621	"tt_default_session()임)"
622	"범주:"
623	"단순히 메세지를 보기만 하려면 범주 보기를 사용하십시오; 메세지 고유의"
624	"처리기로 범주 핸들을 사용하십시오."
625	""
626	"    TT_OBSERVE: 프로세스 보기는 메세지 자체 정보의 복사본을 가져오기만"
627	"                  합니다. 메세지를 볼 수 있는 프로세스 수에는 제한이"
628	"                  없습니다. 메세지가 요구이더라도,"
629	"                  관찰자는 송신자에 값을 되돌려줄 수 없습니다."
630	"                  관찰자가 취한 활동은 잠재적인 도구 데이타의"
631	"                  대화식 표시에만 영향을 주는 것이 보통입니다."
632	""
633	"    TT_HANDLE:  프로세스 처리는 사실 메세지에 기초하여 활동을 수행합니다."
634	"                  주어진 메세지를 한 프로세스만이 처리합니다."
635	"                  메세지가 요구이면, 처리 프로세스는"
636	"                  값을 되돌려주는 프로세스입니다."
637	"                  일반적으로, 처리기가 취한 활동은 해당 도구의 데이타를"
638	"                  계속 저장하는 표시에 영향을 줍니다."
639	"클래스:"
640	"값을 되돌려주는 메세지, 또는 메세지가 처리되거나 대기행렬에 놓이는 시기"
641	"또는 프로세스가 해당 요구를 처리하기 시작하는 시기를 사용자에게 알려주는"
642	"피드백을 원하는 경우 클래스 요구를 사용하십시오. 다른 이벤트의 프로세스를"
643	"알려 주기만 하는 메세지에 대해서는 클래스 알림을 사용하십시오."
644	""
645	"    TT_NOTICE:  알림은 다른 도구에 일부 이벤트가 발생했음을 알리는"
646	"                  메세지입니다. 알림을 보내는 도구들은 응답을 기대하지"
647	"                  않습니다. 송신자는 일어나고 있는 일을 다른 도구들에"
648	"                  알려 줄 뿐입니다."
649	""
650	"    TT_REQUEST: 요구는 또 다른 도구가 활동을 수행하게 하는 메세지입니다."
651	"                  항상 그런 것은 아니지만, 요구 도구는 일부 값이"
652	"                  되돌려지기를 기대할 때가 많습니다. 이 값은"
653	"                  요구에 대한 응답으로 되돌려집니다. 값이 되돌려지지"
654	"                  않더라도, 해당 요구를 처리하는 도구는 성공 또는"
655	"                  실패를 알리는 응답을 보냅니다."
656	"상태:"
657	"메세지의 상태 속성에 대한 값. 예상 값과 그 의미는"
658	"다음과 같습니다."
659	""
660	"    TT_CREATED:  메세지가 만들어졌지만 아직 보내지지 않았습니다. 메세지의"
661	"                   송신자만이 이 상태의 메세지를 보게 됩니다."
662	""
663	"    TT_SENT:   메세지가 보내졌지만 아직 처리되지 않았습니다."
664	""
665	"    TT_HANDLED:  메세지가 처리되었으며, 복귀값이 유효합니다."
666	""
667	"    TT_FAILED:   메세지를 처리기에 전달할 수 없었습니다."
668	""
669	"    TT_QUEUED:   메세지를 나중에 전달하기 위해 대기행렬에 넣었습니다."
670	""
671	"    TT_STARTED:  프로세스를 시작하여 메세지를 처리하려 하는 중입니다."
672	""
673	"    TT_REJECTED: 메세지가 예상 처리기에서 거부되었습니다."
674	"                   이 상태는 거부한 프로세스에서만 보입니다."
675	"                   ToolTalk는 이 메세지를 또 다른 예상 핸들러에 전달하기"
676	"                   전에 상태를 다시 TT_SENT로 바꿉니다."
677	"처분:"
678	"수행중인 프로세스가 메세지를 처리할 수 없을 때 취할 활동을"
679	"지정하십시오. Handler_Ptype의 프로세스가 등록될 때까지 메세지를 대기행렬에"
680	"두어야 한다면 대기행렬에 넣으십시오. Handler_Ptype의 프로세스가 시작되어야"
681	"한다면 시작하십시오."
682	""
683	"    TT_QUEUE: 알맞은 ptype이 메세지를 받을 때까지 메세지를"
684	"                대기행렬에 넣으십시오."
685	""
686	"    TT_START: 수행중인 것이 없다면, 알맞은 ptype의 프로세스를"
687	"                시작해 보십시오."
688	""
689	"Tt_disposition 값을 서로 더할 수 있으므로, TT_QUEUE+TT_START는"
690	"메세지를 대기행렬에 넣음과 동시에 프로세스를 시작한다는 뜻입니다."
691	"이것은 시작이 실패(또는 사용자가 거부)할 수 있기 때문에"
692	"자격있는 프로세스가 시작하자마자 메세지가 처리하려 할 때"
693	"쓸모가 있습니다."
694	"송신자:"
695	"메세지를 보내는 프로세스를 구별합니다."
696	"송신자 ptype:"
697	"메세지를 보내는 프로세스의 ptype."
698	"Args:"
699	"작동에 필요한 인수를 기입하십시오. 각 인수를 차례로 더하려면"
700	"tt_message_arg_add를 사용하십시오. 각 인수에 대해 다음 사항을 지정해야\ 합니다."
701	"모드(in, out, 또는 inout), 유형, 그리고 모드가 in 또는 inout일 경우는 값."
702	"모드:"
703	"메세지 인수의 모드를 지정하십시오.  예상 값과 그 의미는"
704	"다음과 같습니다."
705	""
706	"    TT_IN:    인수는 송신자가 써넣으며 처리기와"
707	"                모든 관찰자가 읽습니다."
708	""
709	"    TT_OUT:   인수는 처리기가 써넣으며 송신자와"
710	"                모든 응답 관찰자가 읽습니다."
711	""
712	"    TT_INOUT: 인수는 송신자와 핸들러와 모든 관찰자가"
713	"                써넣고 읽습니다."
714	"유형:"
715	"유형을 나타내는 문자열. 개발자는 나름대로 값을 만들 수 있지만,"
716	"일반적인 값은 \"String\"과 \"int\"입니다."
717	"값:"
718	"유형에 따른 값의 실제 데이타."
719	"더하기 단추:"
720	"모드, 유형, 값을 가진 인수를 추가합니다."
721	"없애기 단추:"
722	"선택된 인수를 삭제합니다."
723	"바꾸기 단추:"
724	"선택된 인수를 모드, 유형, 그리고 값의 현재값으로"
725	"바꿉니다."
726	"적용 단추:"
727	"이 패턴에 맞는 받을 메세지를 등록합니다."
728	"이름:"
729	"이 문맥의 이름"
730	"값:"
731	"유형에 알맞은 값"
732	""
733	"즉, 정수 유형에 대한 55, 문자 유형에 대한 \"fred\", 또는 바이트 유형에 대한"
734	"^V^L^X를 말합니다."
735	"문맥 더하기:"
736	"문맥의 목록에 이름 및 값 필드의 현재값을"
737	"추가합니다."
738	"문맥 없애기:"
739	"문맥의 목록에서 선택된 항목을 삭제합니다."
740	"문맥 바꾸기:"
741	"선택된 항목을 이름과 값 필드에 있는 것으로 바꿉니다."
742	"보낼 문맥 편집:"
743	"보낼 문맥의 목록을 편집하기 위한 창을 띄워줍니다."
744	"메세지"
745	"------"
746	"메세지를 보내려면, 먼저 새 메세지를 할당하고, 적절한 정보를"
747	"기입한 후, 그것을 보냅니다. 응답은 같은 메세지에 나타나게 됩니다."
748	"메세지를 다 처리했으면, 해당 메세지에 사용한 기억장치를 해제하십시오."
749	"(값을 되돌려 주는 요구에 대해서는 필요한 복귀값이 복사된 후에 기억장치를"
750	"해제하십시오. 단순히 알리는 경우라면, 메세지를 보낸 직후라도 좋습니다.)"
751	""
752	"새 메세지를 할당하려면, tt_message_create()를 사용하십시오. 그것은"
753	"\"handle\" 또는 \"opaque pointer\"를 해당 메세지에 되돌려줍니다."
754	"차후의 호출에서 이 메세지를 참조하려면 이 핸들을 사용하십시오."
755	""
756	"메세지 정보를 기입하려면, tt_message_*_set() 호출을 사용하십시오."
757	"각 메세지 속성마다 다음 중 하나가 있습니다."
758	""
759	"클래스, 주소, OP 및 Args를 설정해야 합니다."
760	""
761	"tt_message_send()로 메세지를 보내십시오."
762	"주소:"
763	"많은 유형의 도구가 있고 사용자마다 서로 다른 시기에"
764	"서로 다른 도구 집합을 사용하므로, 메세지의 송신자가"
765	"정확한 메세지 수신자를 구별하는 것은 불가능할 때가 많습니다."
766	"그보다는, 송신자가 메세지의 의미를 지정하는 작동 이름을 주고"
767	"메세지가 지정되는 오브젝트 또는 오브젝트 유형(otype)을 주는 것이"
768	"더 현실적입니다."
769	""
770	"객체 지향 메세지에 대해서는 오브젝트와 otype을 사용하십시오. 주소가"
771	"처리기라면, 그 처리기를 지정하십시오."
772	""
773	"    TT_PROCEDURE: Op와 Args가 제공됩니다."
774	""
775	"    TT_OBJECT:    오브젝트, Op, 그리고 Args가 제공됩니다."
776	""
777	"    TT_HANDLER:   처리기, Op, 그리고 Args가 제공됩니다."
778	""
779	"    TT_OTYPE:  Otype, Op, 그리고 Args가 제공됩니다."
780	"처리기:"
781	"처리기의 정확한 프로세스 id를 알고 있다면, 메세지를 직접 그것에"
782	"주소 지정할 수 있습니다. 이와 같이 보편적인 방법은 프로세스가 일반적인"
783	"요구를 하고 나서 응답의 처리기 속성을 선택함으로써"
784	"같은 처리기에 메세지를 더 지정하기 위한 것입니다. 이렇게 하면"
785	"프로세스들이 방송 메세지 전달을 통해 만나서 대화로 갈 수"
786	"있게 됩니다."
787	"Handler_Ptype:"
788	"메세지를 처리하게 될 프로세스의 유형을 알고 있다면, 그것을 기입하십시오."
789	"ptype 정의를 살펴보고 프로토콜의 자세한 사항을 알아내면 ptype을"
790	"알 수 있습니다."
791	"오브젝트:"
792	"메세지가 보내질 오브젝트의 objid를 기입하십시오."
793	"Otype:"
794	"오브젝트의 유형."
795	"Op:"
796	"알림 또는 있었던 요구를 설명하는 작동에 기입하십시오."
797	"otype 정의에서 목표 오브젝트를 살펴보고 작동 이름을"
798	"결정하십시오."
799	"범위:"
800	"메세지가 프로세스에 바람직한 것과 같은 세션의 다른 프로세스에서 나온 것이면,"
801	"범위 세션을 사용하십시오. 메세지가 바람직한 파일에 관한 것이면, 범위 파일을"
802	"사용하십시오."
803	""
804	"    TT_SESSION:             사용중인 세션의 다른 프로세스로부터 메세지를"
805	"                           받습니다."
806	""
807	"    TT_FILE:           결합된 파일에 관한 메세지를 받습니다."
808	""
809	"    TT_BOTH:           파일과 세션 둘 다에 관한 메세지를 받습니다."
810	""
811	"    TT_FILE_IN_SESSION:  이 세션중에 결합된 파일에 대한 메세지를"
812	"                           받습니다."
813	"세션:"
814	"범위 세션에 대해서는 해당 세션을 지정하십시오. (기본적으로,"
815	"tt_default_session()임)"
816	"파일:"
817	"파일 범위에 대해서는 해당 파일의 이름을 지정하십시오."
818	"클래스:"
819	"값을 되돌려주는 메세지, 또는 메세지가 처리되거나 대기행렬에 놓이는 시기"
820	"또는 프로세스가 해당 요구를 처리하기 시작하는 시기를 사용자에게 알려주는"
821	"피드백을 원하는 경우 클래스 요구를 사용하십시오. 다른 이벤트의 프로세스를"
822	"알려 주기만 하는 메세지에 대해서는 클래스 알림을 사용하십시오."
823	""
824	"    TT_NOTICE:  알림은 다른 도구에 일부 이벤트가 발생했음을 알리는"
825	"                  메세지입니다. 알림을 보내는 도구들은 응답을 기대하지"
826	"                  않습니다. 송신자는 일어나고 있는 일을 다른 도구들에"
827	"                  알려 줄 뿐입니다."
828	""
829	"    TT_REQUEST: 요구는 또 다른 도구가 활동을 수행하게 하는 메세지입니다."
830	"                  항상 그런 것은 아니지만, 요구 도구는 일부 값이"
831	"                  되돌려지기를 기대할 때가 많습니다. 이 값은"
832	"                  요구에 대한 응답으로 되돌려집니다. 값이 되돌려지지"
833	"                  않더라도, 해당 요구를 처리하는 도구는 성공 또는"
834	"                  실패를 알리는 응답을 보냅니다."
835	"처분:"
836	"수행중인 프로세스가 메세지를 처리할 수 없을 때 취할 활동을"
837	"지정하십시오. Handler_Ptype의 프로세스가 등록될 때까지 메세지를 대기행렬에"
838	"두어야 한다면 대기행렬에 넣으십시오. Handler_Ptype의 프로세스가 시작되어야"
839	"한다면 시작하십시오."
840	""
841	"    TT_QUEUE: 알맞은 ptype이 메세지를 받을 때까지 메세지를"
842	"                대기행렬에 넣으십시오."
843	""
844	"    TT_START: 수행중인 것이 없다면, 알맞은 ptype의 프로세스를"
845	"                시작해 보십시오."
846	""
847	"Tt_disposition 값을 서로 더할 수 있으므로, TT_QUEUE+TT_START는"
848	"메세지를 대기행렬에 넣음과 동시에 프로세스를 시작한다는 뜻입니다."
849	"이것은 시작이 실패(또는 사용자가 거부)할 수 있기 때문에"
850	"자격있는 프로세스가 시작하자마자 메세지가 처리하려 할 때"
851	"쓸모가 있습니다."
852	"Sender_Ptype:"
853	"메세지를 보내는 프로세스의 ptype."
854	"상태:"
855	"응답자가 되돌려준 메세지의 결과를 나타내는 고유 번호."
856	"이 번호는 TT_ERR_LAST (2047)보다 커야 합니다."
857	"상태 문자열:"
858	"메세지의 상태를 설명하는 문자"
859	"Args:"
860	"작동에 필요한 인수를 기입하십시오. 각 인수를 차례로 더하려면"
861	"tt_message_arg_add를 사용하십시오. 각 인수에 대해 다음 사항을 지정해야"
862	"합니다. 모드(in, out, 또는 inout), 유형, 그리고 모드가 in 또는 inout일"
863	"경우는 값."
864	"모드:"
865	"메세지 인수의 모드를 지정하십시오.  예상 값과 그 의미는"
866	"다음과 같습니다."
867	""
868	"    TT_IN:    인수는 송신자가 써넣으며 처리기와"
869	"                모든 관찰자가 읽습니다."
870	""
871	"    TT_OUT:   인수는 처리기가 써넣으며 송신자와"
872	"                모든 응답 관찰자가 읽습니다."
873	""
874	"    TT_INOUT: 인수는 송신자와 핸들러와 모든 관찰자가"
875	"                써넣고 읽습니다."
876	"유형:"
877	"유형을 나타내는 문자열. 개발자는 나름대로 값을 만들 수 있지만,"
878	"일반적인 값은 \"String\"과 \"int\"입니다."
879	"값:"
880	"유형에 따른 값의 실제 데이타."
881	"더하기 단추:"
882	"모드, 유형, 값을 가진 인수를 추가합니다."
883	"없애기 단추:"
884	"선택된 인수를 삭제합니다."
885	"바꾸기 단추:"
886	"선택된 인수를 모드, 유형, 그리고 값의 현재값으로"
887	"바꿉니다."
888	"보내기 단추:"
889	"이 메세지를 보냅니다. 또한 이 메세지를 만들고 보내기 위해"
890	"이루어진 ToolTalk 호출을 표준 출력 장치에 출력합니다."
891	"이름:"
892	"이 문맥의 이름"
893	"값:"
894	"이 문맥의 값, 유형으로 해석됩니다."
895	"더하기:"
896	"문자 필드의 값을 새 문맥으로 추가합니다."
897	"없애기:"
898	"현재 선택된 문맥을 삭제합니다."
899	"바꾸기:"
900	"선택된 문맥을 현재 문자 필드에 있는 것을 반영하도록"
901	"바꿉니다."
902	"선별 출력을 위한 파이프를 열 수 없습니다.\n"
903	"메세지에 대해 Tts_string_list:generate를 호출했습니다. - 무시합니다. \n"
$set 11
2	"TT_OK\t요구가 성공적이었습니다."
3	"TT_WRN_NOTFOUND\t해당 오브젝트는 발견되지 않았기 때문에 삭제되지 않았습니다.\
"
4	"TT_WRN_STALE_OBJID\t메세지의 오브젝트 속성은 새 것으로 바뀌었습니다.\
오브젝트 id를 가져온 장소를 갱신하십시오.\
ained."
5	"TT_WRN_STOPPED\t필터 절차에 의해 조회가 중단되었습니다."
6	"TT_WRN_SAME_OBJID\t옮긴 오브젝트는 같은 objid를 유지합니다."
7	"TT_WRN_START_MESSAGE\t이 메세지는 이 프로세스를 시작하게 합니다.\
  이 메세지는 알림이라 해도 응답해야 합니다."
8	"TT_WRN_APPFIRST\t이 코드는 사용하지 않습니다."
9	"TT_WRN_LAST\t이 코드는 사용하지 않습니다."
10	"TT_ERR_CLASS\t전달된 Tt_class 값이 유효하지 않습니다."
11	"TT_ERR_DBAVAIL\t필요한 데이타베이스를 사용할 수 없습니다. 이 조건은\
일시적인 것일 수 있으므로 나중에 다시 해 보면 작동할 수 있습니다."
12	"TT_ERR_DBEXIST\t필요한 데이타베이스가 없습니다. 이 활동이 작동하려면\
먼저 데이타베이스를 만들어야 합니다."
13	"TT_ERR_FILE\t파일 오브젝트를 찾을 수 없었습니다."
14	"TT_ERR_MODE\tTt_mode 값이 유효하지 않습니다."
15	"TT_ERR_ACCESS\t보호 시스템에 의해 금지된 곳에서 ToolTalk 오브젝트를 \사용하려 했습니다."
16	"TT_ERR_NOMP\tttsession 프로세스가 수행중이지 않습니다. 아마도 tt_open()이\
아직 호출되지 않았기 때문일 것입니다. 이 코드가 tt_open()에서 되돌려진 것이라면,\
그것은 ttsession을 시작할 수 없었다는 뜻입니다. 또한 이것은 대개 ToolTalk가 \이 시가템에 설치되지 않았다는 뜻입니다."
17	"TT_ERR_NOTHANDLER\t메세지의 처리기만이 이것을 할 수 있습니다."
18	"TT_ERR_NUM\t전달된 정수값이 유효하지 않습니다."
19	"TT_ERR_OBJID\t전달된 오브젝트 id가 기존 오브젝트 사양을 참조하지 \않습니다."
20	"TT_ERR_OP\t전달된 작동 이름의 구문이 유효하지 않습니다."
21	"TT_ERR_OTYPE\t전달된 오브젝트 유형이 설치된 오브젝트 유형의 이름이 \아닙니다."
22	"TT_ERR_ADDRESS\t전달된 Tt_address 값이 유효하지 않습니다."
23	"TT_ERR_PATH\t전달된 파일 경로의 디렉토리 중 하나가 없거나 읽을 수 \없습니다."
24	"TT_ERR_POINTER\t전달된 opaque 가리키개(핸들)가 알맞은 유형의 오브젝트를 \나타내지 않습니다."
25	"TT_ERR_PROCID\t전달된 프로세스 id가 유효하지 않습니다."
26	"TT_ERR_PROPLEN\t전달된 특성값이 너무 깁니다."
27	"TT_ERR_PROPNAME\t전달된 특성 이름의 구문이 유효하지 않습니다."
28	"TT_ERR_PTYPE\t전달된 프로세스 유형이 설치된 프로세스 유형의 이름이 아닙니다."
29	"TT_ERR_DISPOSITION\t전달된 Tt_disposition 값이 유효하지 않습니다."
30	"TT_ERR_SCOPE\t전달된 Tt_scope 값이 유효하지 않습니다."
31	"TT_ERR_SESSION\t전달된 세션 id가 활동중인 세션의 이름이 \아닙니다."
32	"TT_ERR_VTYPE\t전달된 값 유형 이름이 유효하지 않습니다."
33	"TT_ERR_NO_VALUE\t주어진 이름과 번호를 가진 특성 값이 \없습니다."
34	"TT_ERR_INTERNAL\t내부 오류(결함)"
35	"TT_ERR_READONLY\t속성을 바꿀 수 없습니다."
36	"TT_ERR_NO_MATCH\t이 메세지에 대한 처리기를 찾을 수 없었습니다. 그리고 \처분이 대기행렬로 들어가거나 시작하지 않았습니다."
37	"TT_ERR_UNIMP\t구현되지 않은 함수입니다."
38	"TT_ERR_OVERFLOW\t활동중인 메세지가 너무 많습니다.(나중에 다시 해 보십시오.)"
39	"TT_ERR_PTYPE_START\t실패한 ptype의 예를 시작하려 하고 있습니다."
40	"TT_ERR_CATEGORY\t패턴 오브젝트에 범주가 설정되지 않았습니다."
41	"TT_ERR_DBUPDATE\t데이타베이스가 일관되지 않습니다. 또 다른 tt_spec_write가\
 오브젝트를 먼저 갱신했습니다."
42	"TT_ERR_DBFULL\tTooltalk 데이타베이스가 꽉 찼습니다."
43	"TT_ERR_DBCONSIST\t데이타베이스가 손상되었거나 사용 정보가 불완전합니다. \(ttdbck를 수행하십시오)."
44	"TT_ERR_STATE\tTt_message가 시도된 작동에 유효하지 않은 \Tt_state에 있습니다."
45	"TT_ERR_NOMEM\t더 이상 메모리가 없습니다."
46	"TT_ERR_SLOTNAME\t슬롯 이름의 구문이 유효하지 않습니다."
47	"TT_ERR_XDR\t전달된 XDR proc.가 0 len으로 평가되거나 호출중에 \실패했습니다."
48	"TT_ERR_NETFILE\t전달된 netfilename의 구문이 유효하지 않습니다."
49	"TT_DESKTOP_UNMODIFIED\t작동이 수정되지 않은 엔티티에는 적용되지 않습니다."
50	"TT_MEDIA_ERR_SIZE\t지정한 크기가 너무 크거나 너무 작습니다."
51	"TT_MEDIA_ERR_FORMAT\t데이타가 인용된 형식을 따르지 않습니다."
52	"TT_ERR_APPFIRST\t이 코드는 사용하지 않습니다."
53	"TT_ERR_LAST\t이 코드는 사용하지 않습니다."
54	"TT_STATUS_LAST\t이 코드는 사용하지 않습니다."
55	"알 수 없는 Tt_status 값."
56	"TT_DESKTOP_EPERM\t수퍼유저가 아닙니다."
57	"TT_DESKTOP_ENOENT\t그러한 파일이나 디렉토리는 없습니다."
58	"TT_DESKTOP_EINTR\t인터럽트된 시스템 호출"
59	"TT_DESKTOP_EIO\tI/O 오류"
60	"TT_DESKTOP_EAGAIN\t더 이상 프로세스가 없습니다."
61	"TT_DESKTOP_ENOMEM\t공간이 부족합니다."
62	"TT_DESKTOP_EACCES\t사용권한이 거부되었습니다."
63	"TT_DESKTOP_EFAULT\t잘못된 주소"
64	"TT_DESKTOP_EEXIST\t파일이 있습니다."
65	"TT_DESKTOP_ENODEV\t그러한 장치는 없습니다."
66	"TT_DESKTOP_ENOTDIR\t디렉토리가 아닙니다."
67	"TT_DESKTOP_EISDIR\t디렉토리입니다."
68	"TT_DESKTOP_EINVAL\t잘못된 인수"
69	"TT_DESKTOP_ENFILE\t파일 테이블 넘침"
70	"TT_DESKTOP_EMFILE\t열린 파일이 너무 많습니다."
71	"TT_DESKTOP_ETXTBSY\t문자 파일이 사용중입니다."
72	"TT_DESKTOP_EFBIG\t파일이 너무 큽니다."
73	"TT_DESKTOP_ENOSPC\t장치에 남아있는 공간이 없습니다."
74	"TT_DESKTOP_EROFS\t읽기 전용 파일 시스템입니다."
75	"TT_DESKTOP_EMLINK\t링크가 너무 많습니다."
76	"TT_DESKTOP_EPIPE\t파이프가 끊어졌습니다."
77	"TT_DESKTOP_ENOMSG\t원하는 메세지 유형이 아닙니다."
78	"TT_DESKTOP_EDEADLK\t데드록 조건"
79	"TT_DESKTOP_ENODATA\t사용가능한 자료가 없습니다."
80	"TT_DESKTOP_EPROTO\t프로토콜 오류"
81	"TT_DESKTOP_ENOTEMPTY\t디렉토리가 비어있지 않습니다."
82	"TT_DESKTOP_ETIMEDOUT\t조건이 시간종료되었습니다."
83	"TT_DESKTOP_EALREADY\t작동이 이미 진행중입니다."
84	"TT_DESKTOP_ECANCELED\t작동이 취소되었습니다."
85	"TT_DESKTOP_ENOTSUP\t지원되지 않습니다."
