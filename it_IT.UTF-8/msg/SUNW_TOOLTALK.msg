$ $TOG: SUNW_TOOLTALK.msg /main/4 1999/09/16 13:44:34 mgreess $
$quote "
$set 1
3	"clnt_create per rpc.ttdbserverd su %s fallito %s"
4	"Errore: il processo rpc.ttdbserverd su %s non è in esecuzione"
6	"La versione del server (%s) non\
corrisponde a quella delle tabelle del database (%s). \
Avviare un server di database in versione %s"
7	"Impossibile aprire la tabella del database %s:%s"
14	"Impossibile cancellare la caratteristica %s della finestra \
radice X che annuncia questa sessione"
15	"La versione dell'indirizzo è %d, ma può essere riconosciuta solo la versione %d! \
(indirizzo: <%s>)"
17	"Impossibile analizzare il nome del display X: \"%s\""
18	"Impossibile mettere in coda un messaggio nel file \"%s\" a causa di \
un errore interno %d"
19	"Impossibile cancellare la vecchia sessione <%s> dalla lista di \
interesse del file \"%s\" a causa di un errore interno %d"
20	"Impossibile cancellare la sessione <%s> dalla lista \
di interesse del file \"%s\" a causa di un errore interno %d"
21	"tttracefile: errore di sintassi nella riga:\n%s"
22	"Impossibile elaborare tttracefile in $%s"
23	"Non è consentito alcun tracing se l'UID reale \
non corrisponde all'UID effettivo"
24	"Accettazione della richiesta"
25	"documento vuoto e nessun file"
26	"Impossibile identificare il messageID; l'operazione potrebbe non essere annullabile a causa di tt_message_arg_val()"
27	"Impossibile identificare il titolo; il documento sarà senza nome a \
causa di tt_message_arg_val()"
28	"offset di opnum sconosciuto"
$set 2
2	"Sono state trovate firme non identificate per ptype %s -"
3	"Nessun trasporto orientato alla connessione"
4	"Un client ToolTalk si è interrotto prima che gli fosse \
segnalato di ripristinare un messaggio richiesto"
5	"Il collegamento con il client ToolTalk si è interrotto mentre gli \
veniva segnalato di ripristinare un messaggio"
6	"È stata trovata un'altra sessione in esecuzione (host=%s, pid=%d)"
7	"Impossibile contattare la sessione prevista (host=%s, pid=%d); \
verrà considerata interrotta..."
8	"Impossibile analizzare l'id di sessione segnalato; l'id verrà sovrascritto..."
9	"%s è un database di tipi in versione %d, che può leggere solo le \
versioni %d e precedenti"
10	"Impossibile decodificare i tipi dal database: %s. È possibile che \
il database sia danneggiato."
11	"%s è stato sovrascritto"
12	"L'attributo sconosciuto <%s> della firma di ToolTalk verrà ignorato..."
13	"ttce2xdr fallito (stato=%d); i tipi contenuti nel database \"user\" \
del Classificatore non sono stati convertiti..."
14	"Record ISAM doppio"
15	"Il file ISAM non è aperto"
16	"Argomento ISAM non valido"
17	"Descrittore della chiave ISAM non valido"
18	"Troppi file ISAM aperti"
19	"Errore nel formato del file ISAM"
20	"Accesso a ISAM non esclusivo"
21	"Record ISAM bloccato"
22	"Chiave ISAM già esistente"
23	"La chiave ISAM è una chiave primaria"
24	"Fine o inizio di un file ISAM"
25	"Non è stato trovato alcun record ISAM"
26	"Non vi è alcun record ISAM corrente"
27	"File ISAM bloccato"
28	"Il nome del file ISAM è troppo lungo"
29	"ISAM non riesce ad allocare memoria"
30	"Timeout RPC ISAM"
31	"Collegamento TCP/IP con ISAM interrotto"
32	"Impossibile collegarsi al server ISAM"
33	"Impossibile importare i dati ISAM"
34	"Nessun daemon SAM locale"
35	"Errore interno fatale di ISAM"
36	"La versione locale ISAM e LANG non corrispondono"
$set 3
2	"Il processo figlio (%d) si è interrotto a causa del segnale %d%s"
3	" (salvato in un core)"
4	"Il processo figlio (%d) non si è interrotto e non è stato segnalato!"
5	"Impossibile ingrandire i client a causa di %m"
6	"Non è stato specificato che cosa gestire. Usare -c, -p, -d, o impostare $DISPLAY."
7	"Impossibile usare l'opzione -S insieme a -c"
8	"Il processo figlio ttsession si è interrotto con lo stato %d"
9	"Il processo figlio ttsession si è interrotto a causa del segnale %d%s"
10	" (salvato in un core)"
11	"Il processo figlio ttsession non si è interrotto e non è stato segnalato!"
12	"Avvio"
13	"Rileggere i tipi"
14	"Errore nei tipi; verranno mantenuti i vecchi tipi"
15	"La variabile $OPENWINHOME non è impostata"
16	"\nSintassi: ttsession [-a unix|des][-d display][-spStvhNX"
17	"][-c comando]\n\
 -c [comando]	avvia una sessione gerarchica del processo e vi esegue il comando.\n\
		Le opzioni successive vengono riferite al comando. Valore predefinito: $SHELL\n\
 -p		avvia una sessione gerarchica del processo e stampa il suo id\n\
 -d display	avvia una sessione X sul display\n\
\n\
 -a unix|des	imposta il livello di autenticazione del server\n\
 -s		esecuzione silente. Non vengono stampati i messaggi di avvertenza\n\
 -S		non esegue fork in background\n\
 -N		utilizza il numero massimo di client consentiti\n\
 -t		abilita la registrazione dei messaggi\n\
 -X		usa i database XDR per i tipi statici (opzione predefinita)\n"
18	" -E		usa il Classificatore per i tipi statici\n"
19	"\n\
 -v		stampa il numero di versione\n\
 -h		stampa questo messaggio\n\
\n\
Interfaccia segnali:\n\
 kill -USR1 ttsession_pid	abilita/disabilita la registrazione dei messaggi\n\
 kill -USR2 ttsession_pid	rilegge i tipi statici"
20	"uscita"
$set 4
2	"Sintassi:\ntt_type_comp [-s] [-d db] [-mM] file_sorgente\ntt_type_comp [-s] [-d db] -r tipo ...\n-M	inserisce i tipi di origine nel database specificato senza aggiornare i tipi esistenti\n-m	inserisce e aggiorna i tipi esistenti. Opzione predefinita.\n-r	elimina i tipi di origine dal database specificato\n\
-d db	database da utilizzare: dell'utente, del sistema o della rete. Valore predefinito: utente\n\n\
-G	raccoglie gli elementi restanti nel server del database di ToolTalk.\n\n\
tt_type_comp [-sE] -p|O|P [-d db]\n\
tt_type_comp [-s]  -p|O|P file_compilato\n\
-O	enumera su stdout i nomi di tutti gli otypes letti\n\
-P	enumera su stdout i nomi di tutti i ptypes letti\n\
-p	stampa su stdout tutti i tipi ToolTalk letti\n\
-E	usa i database del Classificatore anziché i database XDR \n\
-d db	database da cui leggere: dell'utente, del sistema o della rete. Valore predefinito: tutti\n\
\n\
tt_type_comp [-s] -x [-o file_compilato] file_origine\n\
-x	compila i tipi da file_origine (o da stdin, se il file è \"-\")\n\
-o	scrive i tipi compilati in file_compilato (o in stdout, se il file è \"-\")\n\
	Valore predefinito: file_origine.xdr, o \"types.xdr\" se il file è stdin\n\
\n\
tt_type_comp [-hv]\n\
-v	stampa il numero di versione\n\
-h	stampa questo messaggio\n\
-s	non stampa i messaggi di stato.\n\
\n\
Queste opzioni cpp saranno trasmesse come:\n\
        -undef -Dname -Idirectory -Uname -Ydirectory"
3	"Errore semantico nel file dei tipi"
4	"Non è un file di tipi ToolTalk valido"
5	"Impossibile leggere i tipi ToolTalk dal database del Classificatore"
6	"L'unione delle tabelle del Classificatore non è più supportata"
7	"Impossibile leggere i tipi nel database %s - le versioni non \
corrispondono"
8	"Impossibile leggere i tipi nel database %s"
9	"La variabile $OPENWINHOME non è impostata"
10	"Impossibile inizializzare il database %s per la scrittura"
11	"Impossibile eliminare la vecchia definizione per %s"
12	"Sovrascrittura in corso"
13	"Scrittura in corso"
14	"Impossibile aggiungere una nuova definizione per %s"
15	"Impossibile eliminare la vecchia definizione per %s"
16	"Sovrascrittura in corso"
17	"Scrittura in corso"
18	"Impossibile aggiungere una nuova definizione per %s"
19	"Le versioni dei tipi compilati non corrispondono"
20	"Impossibile leggere i tipi nel database"
21	"La variabile $OPENWINHOME non è impostata"
22	"Impossibile leggere i tipi nel database %s - le versioni non corrispondono"
23	"Impossibile leggere i tipi nel database %s"
24	"La variabile $OPENWINHOME non è impostata"
25	"Eliminazione dell'otype %s\n"
26	"Eliminazione del ptype %s\n"
27	"Output scritto in %s\n"
28	"Database non valido: %s"
29	"Specificare solo una delle opzioni -O -P -m -M -p -r -x"
30	"Nessuna preelaborazione eseguita: %s: %s"
31	"Ciclo di ereditarietà di otype contenente %s"
32	"L'antenato %s dell'otype %s non esiste"
33	"Il ptype %s non esiste, ma è stato nominato come implementatore \
dall'otype %s"
34	"Più handler definiti nell'otype %s"
35	"La firma ereditata nell'otype %s non esiste nel padre"
36	"Due ptypes, %s e %s, hanno lo stesso handler"
37	"L'antenato %s dell'otype %s non esiste"
38	"Gerarchia di ereditarietà ciclica dell'otype -\n  {"
39	"Definizioni doppie dell'otype %s"
40	"Definizioni doppie del ptype %s"
$set 5
3	"Violazione della sicurezza: la chiamata RPC ha richiesto l'apertura di \
un file che non è un database ToolTalk"
4	"Tutti i dati scritti usando un rpc.ttdbserverd vecchio (<= 1.0.2) \
dopo avere usato un rpc.ttdbserverd nuovo (>= 1.1) saranno ignorati"
5	"Tutti i dati scritti usando un rpc.ttdbserverd vecchio (<= 1.0.2) \
dopo avere usato un rpc.ttdbserverd nuovo (>= 1.1) saranno ignorati"
6	"La versione di rpc.ttdbserverd (%s) non corrisponde a quella delle \
tabelle del database (%s). Installare la versione %s di rpc.ttdbserverd \
(o una superiore)"
7	"Sintassi:\n\
rpc.ttdbserverd [-S] [-n] [-m PUNTO_DI_MOUNT_DT]\n\
rpc.ttdbserverd [-S] [-v]"
8	"Impossibile avviare il thread di raccolta degli elementi residui. thr_create()\n"
9	"Impossibile eseguire un fork() per la raccolta degli elementi residui.\n"
$set 6
2	"Sintassi:\n\
ttdbck [-f file] [-k chiave_oggetto] [-t tipo] [-bx] \n\
[-impa] [-IZ] [-F nuovo_file] [-T nuovo_tipo] [punti_di_mount]\n"
3	"ttdbck: se è specificata un'opzione di  \
riparazione [-FTZ], occorre specificare un'opzione\n\
di selezione [-fkt] o un'opzione di diagnosi [-bx]\n"
4	"Le versioni dei tipi compilati non corrispondono"
5	"Impossibile leggere i tipi nel database"
6	"ttdbck: provare con 'ttdbck -I'.\n"
7	"Selezionare in base al nome del file: %s\n"
8	"Selezionare in base alla chiave objid:"
9	"Selezionare in base al tipo: %s\n"
10	"Individuare le entità con errori\n"
11	"Individuare i riferimenti ad entità inesistenti\n"
12	"Visualizzare gli id\n"
13	"Visualizzare i dati obbligatori\n"
14	"Visualizzare le caratteristiche e i valori\n"
15	"Chiamare la funzione NetISAM isrepair() prima dell'ispezione\n"
16	"Correggere impostando il tipo: %s\n"
17	"Correggere con una cancellazione\n"
18	"Debugging a livello di printout %d\n"
19	"Correggere impostando il file: %s\n"
20	"Errore: nessun file per spec.\n"
21	"Errore: nessun tipo per spec.\n"
22	"Errore: \"%s\" non è un otype installato.\n"
23	"Errore: spec ha più valori per la caratteristica tipo.\n"
24	"Errore: "
25	"ttdbck: nessun errore trovato.\n"
26	"Errore: "
$set 7
2	"Sintassi: %s {ctx}[fhpPv[v]] [file_tar] percorso ...\n\
       %s {ctx}fL[hpPRv[v]] tttarfile percorso ...\n\
       %s -v\n\
       %s -h\n"
3	"\tc       crea un archivio\n\
\tt       elenca il contenuto di un archivio\n\
\tx       estrae il contenuto di un archivio\n\
\tf       usa l'argomento <file_tar> successivo come archivio\n\
\th       segue i collegamenti simbolici\n\
\tL       non richiama tar(1)\n\
\tp       preserva il modo dei file\n\
\tP       (superutente) non preserva il proprietario, il modo, l'ora, \
ecc. degli oggetti\n\
\tR       non esegue il comando in modo ricorsivo nelle directory\n\
\tv       esegue il comando in modo esplicito\n\
\tvv      esegue il comando in modo esplicito e dettagliato\n\
\t-v      visualizza il numero di versione ed esce\n\
\t-h[elp] visualizza questo messaggio\n"
4	"%s: Impossibile leggere il tipo di oggetto dal contenuto dell'archivio.\n"
5	"%s: Impossibile leggere la versione dell'archivio dal suo contenuto.\n"
6	"%s: È stata trovata la versione %d, mentre era attesa la versione %d.\n"
7	"%s: È stato trovato un oggetto di tipo sconosciuto %d nell'archivio.\n"
8	"%s: Impossibile leggere il tipo di oggetto dal contenuto dell'archivio.\n"
9	"%s: Impossibile leggere la versione dell'archivio dal suo contenuto.\n"
10	"%s: È stata trovata la versione %d, mentre era attesa la versione %d.\n"
11	"%s: È stato trovato un oggetto di tipo sconosciuto %d nell'archivio.\n"
$set 8
2	"%s: Impossibile eliminare gli oggetti ToolTalk di %s a causa di %s\n"
3	"%s: Impossibile spostare gli oggetti ToolTalk \"%s\" in \"%s\" a \
causa di %s\n"
4	"%s: Non verranno spostati gli oggetti ToolTalk di:\n"
5	"Sintassi: %s [-] [-fL] percorso1 percorso2\n\
       %s [-] [-fL] percorso1 [percorso2 ...] dir\n\
       %s -v\n\
       %s -h\n"
6	"\t-L      non esegue mv(1)\n\
\t-v      visualizza il numero di versione ed esce\n\
\t-h      visualizza questo messaggio\n"
7	"%s: Impossibile eliminare gli oggetti ToolTalk di %s a causa di %s\n"
8	"Sintassi: %s [-] [-%s] %s ...\n       %s -v\n       %s -h\n"
9	"file"
10	"dir"
11	"\t-L      non esegue %s(1)\n\
\t-v      visualizza il numero di versione ed esce\n\
\t-h[elp] visualizza questo messaggio\n"
12	"%s: Impossibile eliminare gli oggetti ToolTalk di %s a causa di %s\n"
13	"Sintassi: %s [-pL] file1 file2\n\
       %s [-prRL] percorso1 [percorso2 ...] dir\n\
       %s -v\n\
       %s -h\n"
14	"\t-L      non esegue cp(1)\n\
\t-v      visualizza il numero di versione ed esce\n\
\t-h      visualizza questo messaggio\n"
$set 9
2	"Sintassi: %s [-0FCa][-o file_output] [-S sessione | comando [opzioni]]\n\
       %s [-e script | -f file_script][-S sessione | comando [opzioni]]\n\
 -0		Disabilita la traccia dei messaggi nella sessione, o esegue\n\
		il comando senza tracciare i messaggi (solo traccia API)\n\
 -F		Segue tutti i processi figli biforcati dal comando o avviati\n\
		successivamente nella sessione con ttsession(1)\n\
 -C		Non traccia le chiamate della API ToolTalk\n\
 -a		Stampa tutti gli attributi, gli argomenti e i contesti dei\n\
		messaggi registrati. Valore predefinito: sommario su un'unica riga.\n\
 -e script	Legge le impostazioni di tttracefile(4) dallo script\n\
 -f file_script	Legge le impostazioni di tttracefile(4) dal file_script. \"-\": stdin.\n\
 -o file_output	Output. \"-\": stdout. Valore predefinito: stdout per la registrazione \n\
		della sessione, stderr (di tttrace) per la registrazione del comando\n\
 -S sessione	Sessione da registrare. Valore predefinito: vedere tt_default_session()\n\
 comando	Comando del client ToolTalk da richiamare e registrare\n"
3	"%s: la sessione <%s> non supporta Session_Trace. Usare kill -USR1. \
Vedere ttsession(1).\n"
$set 10
2	"Viene ignorato un Tt_address sconosciuto trasmesso a Tts_address::add()\n"
3	"Viene ignorato un Tt_address sconosciuto trasmesso a \
Tts_address::remove()\n"
4	"Viene ignorato un indirizzo sconosciuto trasmesso a \
tts_address::tts_set()\n"
5	"Viene ignorato un indirizzo sconosciuto trasmesso a \
tts_address::tts_unset()\n"
6	"Viene ignorato un indirizzo sconosciuto letto da tts_address::load()\n"
7	"Tts_arglist::Tts_arglist - errore nella lettura dell'argomento - \n\t"
8	"Tts_arglist::load - È stato rilevato un tipo di argomento \
sconosciuto - verrà usato BARG\n"
9	"È stata chiamata la classe astratta Tts_arg::assign (Tt_pattern) - \
comando ignorato\n"
10	"È stata chiamata la classe astratta Tts_arg::assign(Tt_message) - \
comando ignorato\n"
11	"È stata chiamata la classe astratta Tts_arg::generate - comando \
ignorato\n"
12	"È stata chiamata la classe astratta Tts_arg::save - comando ignorato\n"
13	"È stata chiamata la classe astratta Tts_arg::load - comando ignorato\n"
14	"Tts_arg::mode_to_chars non è un modo ammesso - verrà usato TT_INOUT\n"
15	"Tts_arg::chars_to_mode non è un modo ammesso - verrà usato TT_INOUT\n"
16	"Viene ignorata una Tt_category sconosciuta trasmessa a \
Tts_category::set()\n"
17	"Tts_category::generate() ha richiesto un messaggio - comando ignorato\n"
18	"Viene ignorata una categoria sconosciuta letta da tts_category::load()\n"
19	"Viene ignorata una Tt_class sconosciuta trasmessa a Tts_class::add()\n"
20	"Viene ignorata una Tt_class sconosciuta trasmessa a Tts_class::remove()\n"
21	"Viene ignorata una classe sconosciuta trasmessa a tts_class::tts_set()\n"
22	"Viene ignorata una classe sconosciuta trasmessa a \
tts_class::tts_unset()\n"
23	"Viene ignorata una classe sconosciuta letta da tts_class::load()\n"
24	"Tts_connection::universal_callback - nessun molding \
per il pattern!\n"
25	"Tts_cntxtlist::Tts_cntxtlist - errore nella lettura del contesto - \n\t"
26	"Tts_contextlist::load - È stato rilevato un tipo di contesto \
sconosciuto - verrà usato BCNTXT\n"
27	"È stata chiamata la classe astratta Tts_context::assign \
(Tt_pattern) - comando ignorato\n"
28	"È stata chiamata la classe astratta Tts_context::assign \
(Tt_pattern) - comando ignorato\n"
29	"È stata chiamata la classe astratta Tts_context::generate - comando \
ignorato\n"
30	"È stata chiamata la classe astratta Tts_context::save - comando \
ignorato\n"
31	"È stata chiamata la classe astratta Tts_context::load - comando \
ignorato\n"
32	"Viene ignorata una Tt_disposition sconosciuta trasmessa a \
Tts_disposition::add()\n"
33	"Viene ignorata una Tt_disposition sconosciuta trasmessa a \
Tts_disposition::remove()\n"
34	"Viene ignorata una disposizione sconosciuta trasmessa a \
tts_disposition::tts_set()\n"
35	"Viene ignorata una disposizione sconosciuta trasmessa a \
tts_disposition::tts_unset()\n"
36	"Viene ignorata una disposizione sconosciuta letta da \
tts_disposition::load()\n"
37	"È stato chiamato %s\n"
38	"Errore di ToolTalk: %s\n        Origine: File %s riga %d\n"
39	"Attenzione: %s\n        Origine: File %s riga %d\n"
40	" Tts_message_molding::send - Tentativo di inviare un messaggio non inizializzato\n"
41	"Viene ignorato un Tt_scope sconosciuto trasmesso a Tts_scope::add()\n"
42	"Viene ignorato un Tt_scope sconosciuto trasmesso a Tts_scope::remove()\n"
43	"Viene ignorato uno scope sconosciuto trasmesso a tts_scope::tts_set()\n"
44	"Viene ignorato uno scope sconosciuto trasmesso a tts_scope::tts_unset()\n"
45	"Viene ignorato uno scope sconosciuto letto da tts_scope::load()\n"
46	"Viene ignorato un Tt_state sconosciuto trasmesso a Tts_state::add()\n"
47	"Viene ignorato un Tt_state sconosciuto trasmesso a Tts_state::remove()\n"
48	"Viene ignorato uno stato sconosciuto trasmesso a tts_state::tts_set()\n"
49	"Viene ignorato uno stato sconosciuto trasmesso a tts_state::tts_unset()\n"
50	"Tts_state::generate() richiedeva un messaggio - comando ignorato\n"
51	"Viene ignorato uno stato sconosciuto letto da tts_state::load()\n"
82	"Come richiamare l'aiuto su TTSnoop"
83	"----------------------------------"
84	"Per ottenere informazioni dettagliate su un pulsante o su un campo,"
85	"premere il tasto Help della tastiera tenendo il mouse sopra l'oggetto"
86	"o l'area di interesse. Per vedere quali chiamate API sono attualmente"
87	"utilizzate da ttsnoop, usare l'opzione -t insieme al comando ttsnoop."
88	""
89	"Uso di TTSnoop"
90	"--------------"
91	"Per osservare i messaggi, selezionare l'opzione Start."
92	""
93	"Per disabilitare l'osservazione dei messaggi, selezionare l'opzione Stop."
94	""
95	"Per limitare i tipi di messaggi:"
96	"      1) Fare clic sul pulsante Patterns"
97	"      2) Inserire il tipo di pattern che si desidera osservare"
98	"      3) Scegliere Apply"
99	""
100	"Per evidenziare le informazioni visualizzate:"
101	"      1) Fare clic sul pulsante Display"
102	"      2) Contrassegnare gli elementi che si desidera evidenziare"
103	"      3) Scegliere Apply"
104	""
105	"Per inviare un messaggio:"
106	"      1) Fare clic sul pulsante Messages"
107	"      2) Comporre il messaggio"
108	"      3) Scegliere Send Message"
109	""
110	"Per memorizzare un messaggio:"
111	"      1) Fare clic sul pulsante Messages"
112	"      2) Comporre il messaggio"
113	"      3) Scegliere Add Message"
114	""
115	"Per inviare un messaggio memorizzato:"
116	"      Selezionare il messaggio dal menu Send Message"
117	""
118	"Per azzerare la finestra di output dei messaggi, scegliere Clear"
119	""
120	"Informazioni generali su ToolTalk"
121	"---------------------------------"
122	"Per poter inviare o ricevere messaggi orientati"
123	"agli oggetti tramite ToolTalk, un processo deve"
124	"registrarsi con il message passer. Nella registrazione,"
125	"il processo trasmette a ToolTalk diverse informazioni:"
126	""
127	"      Il tipo di processo (ptype) a cui appartiene."
128	"      Questo consente al message passer di dirigere"
129	"      i messaggi implementati da questo ptype al"
130	"      processo."
131	""
132	"      Le sessioni a cui partecipa."
133	""
134	"      I documenti che sta osservando."
135	"      In questo modo, i messaggi diretti ad oggetti"
136	"      di questi documenti potranno essere indirizzati"
137	"      al processo."
138	""
139	"Si noti che, di norma, queste registrazioni modificano"
140	"i pattern generati. È possibile usare le chiamate API"
141	"di manipolazione dei pattern per osservare o gestire"
142	"i messaggi orientati agli oggetti, ma i metodi qui"
143	"descritti sono molto più rapidi in quanto sfruttano"
144	"le informazioni dichiarate nelle definizioni dei file."
145	""
146	"Per partecipare a una sessione si può usare"
147	"tt_session_join. È necessario fornire l'id della"
148	"sessione a cui si desidera partecipare."
149	""
150	"Quando il tool utilizzato non richiede più i servizi"
151	"ToolTalk, uscire dalla sessione con tt_session_quit."
152	""
153	"Ogni volta che il tool utilizzato carica un file, esso"
154	"deve unirsi al gruppo dei processi interessati a quel"
155	"file chiamando tt_file_join(); terminato l'uso del file,"
156	"il tool può uscire dal gruppo chiamando tt_file_quit()."
157	"Alcuni tool possono tenere aperti più file simulta-"
158	"neamente; altri possono aprirne solo uno alla volta."
159	""
160	"Uso di TTSnoop"
161	"--------------"
162	"Per osservare i messaggi, selezionare Start."
163	"Per disabilitare l'osservazione dei messaggi, selezionare Stop."
164	""
165	"Per limitare i tipi di messaggi:"
166	"        1) Fare clic sul pulsante Patterns"
167	"        2) Inserire il tipo di pattern che si desidera osservare"
168	"        3) Scegliere Apply"
169	""
170	"Per evidenziare le informazioni visualizzate:"
171	"        1) Fare clic sul pulsante Display"
172	"        2) Contrassegnare gli elementi che si desidera evidenziare"
173	"        3) Scegliere Apply"
174	""
175	"Per inviare un messaggio:"
176	"        1) Fare clic sul pulsante Messages"
177	"        2) Comporre il messaggio"
178	"        3) Scegliere Send Message"
179	""
180	"Per memorizzare un messaggio:"
181	"        1) Fare clic sul pulsante Messages"
182	"        2) Comporre il messaggio"
183	"        3) Scegliere Add Message"
184	""
185	"Per inviare un messaggio memorizzato:"
186	"        Selezionare il messaggio dal menu Send Message"
187	""
188	"Per azzerare la finestra di output dei messaggi, scegliere Clear."
189	""
190	"Informazioni generali su ToolTalk"
191	"---------------------------------"
192	"Per poter inviare o ricevere messaggi orientati agli oggetti tramite"
193	"ToolTalk, un processo deve registrarsi con il message passer. Nella"
194	"registrazione, il processo trasmette a ToolTalk diverse informazioni:"
195	""
196	"        Il tipo di processo (ptype) a cui appartiene. Questo"
197	"        consente al message passer di dirigere i messaggi"
198	"        implementati da questo ptype al processo."
199	""
200	"        Le sessioni a cui partecipa."
201	""
202	"        I documenti che sta osservando. In questo modo, i messaggi"
203	"        diretti ad oggetti di questi documenti potranno essere"
204	"        indirizzati al processo."
205	""
206	"Si noti che, di norma, queste registrazioni modificano i pattern"
207	"generati. È possibile usare le chiamate API di manipolazione dei"
208	"pattern per osservare o gestire i messaggi orientati agli oggetti,"
209	"ma i metodi qui descritti sono molto più rapidi in quanto sfruttano"
210	"le informazioni dichiarate nelle definizioni dei file."
211	""
212	"Per partecipare a una sessione si può usare tt_session_join,"
213	"specificando l'id della sessione desiderata."
214	""
215	"Quando il tool utilizzato non richiede più i servizi "
216	"ToolTalk, uscire dalla sessione con tt_session_quit."
217	""
218	"Ogni volta che il tool utilizzato carica un file, esso deve"
219	"unirsi al gruppo dei processi interessati a quel file chiamando"
220	"tt_file_join(); terminato l'uso del file, il tool può uscire"
221	"dal gruppo chiamando tt_file_quit(). Alcuni tool possono tenere"
222	"aperti più file; altri possono aprirne solo uno alla volta"
223	"Usare Start/Stop per il ricevimento e la visualizzazione dei messaggi."
224	"Usare Clear per azzerare la finestra dei messaggi."
225	"Display"
226	"------------"
227	"Quando arriva un messaggio per il processo in uso, viene attivato un"
228	"descrittore del file. A seconda della struttura del tool utilizzato,"
229	"è possibile predisporre il toolkit del sistema a finestre perché chiami"
230	"un callback ogni volta che il descrittore del file diventa attivo, o"
231	"includere il descrittore in una chiamata select(3) che si blocchi su una"
232	"serie di descrittori. In entrambi i casi, una volta attivato il \
descrittore"
233	"del file occorre chiamare tt_message_receive() per ottenere uno handle per"
234	"un messaggio che contenga quello in arrivo. Dalle chiamate tt_message_*()"
235	"si possono estrarre gli attributi del messaggio per determinare l'azione"
236	"più appropriata da compiere. Per identificare le risposte ai messaggi è"
237	"possibile confrontare gli handle, inserire informazioni significative per"
238	"la propria applicazione nel messaggio con la chiamata \
tt_message_user_set(),"
239	"oppure inserire callback specifici in messaggi e pattern con le chiamate"
240	"tt_message_callback_add e tt_pattern_callback_add."
241	"Messages"
242	"--------"
243	"Per inviare un messaggio: allocare un nuovo messaggio, inserirvi le"
244	"informazioni appropriate e quindi inviarlo. Le risposte compariranno"
245	"nello stesso messaggio. Al termine, liberare la memoria occupata."
246	"(Per le richieste che restituiscono un valore, liberare la memoria dopo"
247	"aver copiato i valori di ritorno richiesti; per le notifiche, procedere"
248	"subito dopo l'invio). "
249	"Per allocare il nuovo messaggio, usare tt_message_create(), che \
restituirà"
250	"un \"handle\" o \"puntatore opaco\" per il messaggio; questo \
handle dovrà"
251	"essere usato nelle chiamate successive per riferirsi a quel messaggio."
252	""
253	"Per inserire le informazioni, usare le chiamate tt_message_*_set();"
254	"ne esiste una per ogni attributo del messaggio."
255	""
256	"Impostare Class, Address, Op e Arguments."
257	""
258	"Inviare il messaggio con tt_message_send()."
259	"Patterns"
260	"--------"
261	"Poiché il processo di invio non indirizza il messaggio esplicitamente a"
262	"un destinatario, per determinare quest'ultimo viene usato il metodo del"
263	"\"confronto dei pattern\". I tool registrano le \
descrizioni dei messaggi a"
264	"cui sono interessati, e ToolTalk le utilizza per inferire l'instradamento"
265	"del messaggio. Insiemi di pattern separati descrivono i messaggi che"
266	"il tool desidera gestire e quelli che desidera osservare. I tool che"
267	"desiderano ricevere messaggi possono dichiararlo in modo dinamico, al"
268	"momento dell'esecuzione, o statico, in fase di installazione. Una regi-"
269	"strazione dinamica consiste in una serie di pattern con cui vengono"
270	"confrontati tutti i messaggi. Se un messaggio corrisponde al pattern,"
271	"il tool che ha registrato quel pattern sarà candidato per \
riceverlo."
272	""
273	"Per poter ricevere messaggi procedurali tramite ToolTalk, un processo"
274	"deve registrarsi con il message passer. Alla registrazione, il processo"
275	"specifica una serie di pattern a ToolTalk, il quale gli consegnerà i"
276	"messaggi corrispondenti. I pattern possono essere \
creati:"
277	""
278	"Staticamente, mediante un ptype. Un processo dichiara il suo ptype al"
279	"message passer; ToolTalk genera quindi i pattern da ogni firma del"
280	"ptype. Questi pattern possono essere modificati mediante l'ingresso \
e l'uscita"
281	"da sessioni e file, come nel passaggio dei messaggi orientati agli oggetti."
282	""
283	"Dinamicamente. Un processo crea i pattern \"sul momento\" e li registra"
284	"con ToolTalk. Un'applicazione tipica di questa funzione può essere \
un tool"
285	"di registrazione dei messaggi che osservi semplicemente tutti i messaggi"
286	"in transito e li visualizzi in una finestra; un tool di questo tipo"
287	"può essere utile nel debugging dei protocolli dei messaggi."
288	""
289	"Questa applicazione utilizza solo i pattern dinamici."
290	""
291	"Per registrare un pattern occorre: allocare un nuovo pattern, inserirvi"
292	"le informazioni appropriate e quindi registrarlo. Terminato l'uso del"
293	"pattern (quando cioè non si è più interessati ai messaggi corrispondenti"
294	"a quel pattern), liberare la memoria occupata."
295	""
296	"Per allocare il nuovo pattern, usare tt_pattern_create(), che restituirà"
297	"uno \"handle\" o \"puntatore opaco\"; questo handle dovrà essere usato"
298	"nelle chiamate successive per riferirsi a quel pattern."
299	""
300	"Per inserire le informazioni, usare le chiamate tt_pattern_*_add(); ne"
301	"esiste una per ogni attributo del pattern. È possibile indicare più"
302	"valori per ogni attributo; un attributo del pattern corrisponderà"
303	"a un attributo del messaggio quando uno qualsiasi dei valori"
304	"specificati nel pattern corrisponderà al valore del messaggio."
305	""
306	"Per gli attributi multipli, questa applicazione utilizza impostazioni"
307	"non esclusive e valori separati da virgole."
308	""
309	"Per individuare i messaggi di interesse indipendentemente dal valore di"
310	"un dato attributo, è sufficiente omettere tale attributo nel pattern."
311	""
312	"Se nel pattern non è specificato alcun attributo, ToolTalk considera"
313	"l'attributo del messaggio come corrispondente. Riducendo il numero di"
314	"attributi nel pattern si aumenterà il numero dei messaggi ricevibili."
315	""
316	"Se nel pattern sono specificati più valori per un dato attributo, almeno"
317	"uno deve corrispondere al valore del messaggio. Se nessuno dei \
valori corri-"
318	"sponde, ToolTalk non considera l'applicazione come potenziale \
destinataria."
319	""
320	"Gli attributi Category e Scope devono sempre essere specificati."
321	""
322	"Quando il pattern è completo, registrarlo con tt_pattern_register()"
323	"e quindi unirsi alle sessioni o ai file richiesti selezionando"
324	"il pulsante Apply."
325	""
326	"Poiché i pattern registrati vengono aggiornati al momento \
dell'unione"
327	"a file e sessioni, le registrazioni eseguite dopo un'unione non saranno incluse"
328	"nell'aggiornamento. Occorrerà perciò registrare tutti i pattern \
prima "
329	"dell'unione, oppure ripetere l'unione ogni volta che si registra un \
nuovo pattern."
330	"Questo vale anche per i pattern registrati implicitamente con l'unione"
331	"dei ptype. Aggiungendo i messaggi dalla finestra Messages, il menu \
corrispon-"
332	"dente si allungherà. Per inviare un messaggio sarà sufficiente selezionarlo."
333	"Address:"
334	"Poiché esistono molti tipi di tool, e gli utenti utilizzano \
tool diversi"
335	"in momenti diversi, è spesso impossibile per il mittente di un messaggio"
336	"identificare con precisione il suo destinatario. Perciò, il \
mittente assegna"
337	"al messaggio il nome di un'operazione che ne specifica il significato, ed"
338	"eventualmente indica un oggetto, o il tipo di oggetto (otype) a cui il"
339	"messaggio è diretto."
340	""
341	"Per i messaggi orientati agli oggetti, usare un oggetto o un \
otype. Se l'indirizzo"
342	"è uno handler, specificarne il nome."
343	""
344	"        TT_PROCEDURE: Op e Args specificati."
345	""
346	"        TT_OBJECT:    Object, Op e Args specificati."
347	""
348	"        TT_HANDLER:   Handler, Op e Args specificati."
349	""
350	"        TT_OTYPE:     Otype, Op e Args specificati."
351	"Handler:  "
352	"Se si conosce il procid esatto dello handler, è possibile \
indirizzargli i"
353	"messaggi direttamente. In un caso tipico, un processo effettua"
354	"una richiesta generale e quindi estrae l'attributo Handler dalla \
risposta,"
355	"dirigendo gli ulteriori messaggi allo stesso handler; questo \
consente a due"
356	"processi di incontrarsi attraverso il passaggio dei messaggi trasmessi e"
357	"di iniziare a dialogare."
358	"Handler_Ptype:"
359	"Se si conosce il ptype del processo che gestirà il messaggio, \
specificarlo."
360	"Il ptype è contenuto nella definizione del ptype che specifica"
361	"i particolari del protocollo."
362	"Object:"
363	"Specificare l'objid dell'oggetto a cui il messaggio deve essere inviato."
364	"OType:"
365	"Tipo dell'oggetto."
366	"Op:"
367	"Specificare l'operazione che descrive la notifica o la richiesta in"
368	"corso. Per determinare il nome dell'operazione, consultare la"
369	"definizione dell'otype dell'oggetto di destinazione."
370	"Opnum:"
371	"Numero dell'operazione. Viene usato per distinguere tra le operazioni"
372	"overloaded (operazioni con lo stesso nome ma con tipi di argomenti"
373	"diversi), e per semplificare gli invii \"interni\" dei client (il richiamo"
374	"della procedura interna appropriata per un dato messaggio.)"
375	"Scope:"
376	"La sessione scope viene usata per ricevere messaggi di altri"
377	"processi della stessa sessione; il file scope viene usato per"
378	"ricevere messaggi su un file."
379	""
380	"      TT_SESSION:          Riceve messaggi di altri processi della"
381	"                           sessione corrente."
382	""
383	"      TT_FILE:             Riceve messaggi sul file unito."
384	""
385	"      TT_BOTH:             Riceve messaggi su un file e sulla"
386	"                           sessione."
387	""
388	"      TT_FILE_IN_SESSION:  Riceve messaggi per il file unito"
389	"                           mentre si trova nella sessione corrente."
390	"Session:"
391	"Per le sessioni scope, specificare la sessione (tt_default_session()"
392	"è il valore predefinito)."
393	"File:"
394	"Per lo scope del file, specificare il nome del file."
395	"Category:"
396	"Usare la categoria observe se si desidera soltanto osservare i messaggi; usare"
397	"la categoria handle per candidarsi come unico handler del messaggio."
398	""
399	"    TT_OBSERVE: I processi di osservazione ottengono solo copie del messaggio"
400	"                per informazione. Un messaggio può essere osservato da un"
401	"                numero qualsiasi di processi. I processi osservatori non possono"
402	"                mai restituire valori al mittente, neppure se il messaggio è una"
403	"                richiesta. In genere, le azioni degli osservatori hanno effetto solo"
404	"                sulla visualizzazione interattiva dei dati del tool sottostante."
405	""
406	"    TT_HANDLE:  I processi di gestione eseguono effettivamente un'azione basata"
407	"                sul messaggio. Un dato messaggio può essere gestito da un solo"
408	"                processo. Se il messaggio è una richiesta, il processo di gestione"
409	"                è quello che restituisce i valori richiesti. In genere, le azioni"
410	"                dei processi di gestione hanno effetto sulla rappresentazione"
411	"                dei dati del tool memorizzata in modo permanente."
412	"Class:"
413	"Usare la classe request per i messaggi che restituiscono un valore, o per"
414	"i quali si desidera un feedback che indichi se il messaggio viene gestito o è in coda,"
415	"o quando viene avviato un processo per gestire la richiesta. Usare la classe notice"
416	"per i messaggi che si limitano a notificare gli eventi ad altri processi."
417	""
418	"    TT_NOTICE:   Le notifiche sono messaggi che informano altri tool di un"
419	"                 evento accaduto. I tool che inviano notifiche non attendono"
420	"                 una risposta; il mittente desidera soltanto informare"
421	"                 gli altri tool di quanto sta accadendo."
422	""
423	"     TT_REQUEST: Le richieste sono messaggi che chiedono a un altro tool di"
424	"                 eseguire un'azione. Spesso, ma non sempre, il tool richiedente"
425	"                 aspetta un valore di ritorno, restituito come risposta"
426	"                 alla richiesta. Anche se non viene restituito alcun"
427	"                 valore, il tool che elabora la richiesta invia una"
428	"                 risposta indicante il successo o meno dell'operazione."
429	"Disposition:"
430	"Specifica l'azione da intraprendere se il messaggio non può essere gestito da"
431	"nessuno dei processi attivi. Queue indica che il messaggio deve essere collocato"
432	"in coda in attesa della registrazione di un processo dell'Handler_Ptype. Start indica"
433	"che occorre avviare un processo dell'Handler_Ptype."
434	""
435	"    TT_QUEUE: Il messaggio viene messo in coda in attesa di essere ricevuto"
436	"              da un processo del ptype appropriato."
437	""
438	"    TT_START: È in corso un tentativo di avviare un processo del ptype"
439	"              appropriato."
440	""
441	"Si noti che i valori di Tt_disposition possono essere sommati, per cui"
442	"TT_QUEUE+TT_START comprende sia il collocamento in coda del messaggio"
443	"che l'avvio del processo. Questo è utile nei casi in cui l'avvio possa fallire"
444	"(o essere bloccato dall'utente), per garantire che il messaggio venga elaborato"
445	"non appena si riesca ad avviare un processo adatto."
446	"State:"
447	"Valori per l'attributo State di un messaggio. Qui di seguito sono elencati"
448	"i valori possibili e i relativi significati:"
449	""
450	"    TT_CREATED:  Il messaggio è stato creato ma non ancora inviato. Un messaggio"
451	"                 in questo stato può essere visto solo dal mittente."
452	""
453	"    TT_SENT:     Il messaggio è stato inviato ma non ancora gestito."
454	""
455	"    TT_HANDLED:  Il messaggio è stato gestito, i valori restituiti sono validi."
456	""
457	"    TT_FAILED:   Il messaggio non ha potuto essere consegnato a uno handler."
458	""
459	"    TT_QUEUED:   Il messaggio è stato messo in coda per la consegna in un momento successivo."
460	""
461	"    TT_STARTED:  Si cerca di avviare un processo in grado di gestire il messaggio."
462	""
463	"    TT_REJECTED: Il messaggio è stato respinto da un potenziale handler."
464	"                 Questo stato viene visto solo dal processo che rifiuta la"
465	"                 gestione; ToolTalk ripristina lo stato a TT_SENT e quindi"
466	"                 consegna il messaggio a un altro potenziale handler."
467	"Status:"
468	"Numero unico indicante i risultati della risposta al messaggio."
469	"Il numero deve essere maggiore di TT_ERR_LAST (2047)."
470	"Stringa Status:"
471	"Descrizione in formato testo dello Status del messaggio."
472	"Sender:"
473	"Identifica il processo che ha inviato il messaggio."
474	"Sender ptype:"
475	"È il ptype del processo che ha inviato il messaggio."
476	"Uid:"
477	"Identificativo dell'utente del processo che ha inviato il messaggio."
478	"Gid:"
479	"Identificativo del gruppo del processo che ha inviato il messaggio."
480	"Mode:"
481	"Specifica la modalità di un argomento del messaggio. Qui di seguito sono"
482	"elencati i possibili valori e i relativi significati:"
483	""
484	"    TT_IN:    L'argomento viene scritto dal mittente e letto"
485	"              dallo handler e dagli eventuali osservatori."
486	""
487	"    TT_OUT:   L'argomento viene scritto dallo handler e letto"
488	"              dallo handler e da eventuali osservatori della risposta."
489	""
490	"    TT_INOUT: L'argomento viene scritto e letto dal mittente,"
491	"              dallo handler e da eventuali osservatori."
492	"Type:"
493	"Stringa indicante il tipo. I valori più usati sono \"string\" e \"int\","
494	"ma gli sviluppatori possono crearne di propri."
495	"Value:"
496	"Dati effettivi del valore, dipendenti dal tipo."
497	"Premendo il pulsante Apply, i valori dei parametri specificati"
498	"verranno visualizzati per tutti i messaggi ricevuti."
499	"I valori di display verranno ripristinati allo stato dell'ultima"
500	"operazione Apply o al valore iniziale (prevarrà l'ultimo valore applicato)."
501	"Edit Receive Contexts:"
502	"Scegliere Add, Delete o Change per aggiungere, cancellare o modificare i contesti."
503	"Pattern Match"
504	"-------------"
505	"Poiché il processo di invio non indirizza il messaggio esplicitamente a"
506	"un destinatario, per determinare quest'ultimo viene usato il metodo del"
507	"\"confronto dei pattern\". I tool registrano le descrizioni dei"
508	"messaggi a cui sono interessati, e ToolTalk le utilizza per inferire"
509	"l'instradamento del messaggio. Set di pattern separati descrivono i"
510	"messaggi che il tool desidera gestire e quelli che desidera osservare."
511	"I tool che desiderano ricevere messaggi possono dichiararlo in"
512	"modo dinamico, al momento dell'esecuzione, o in modo statico, in fase"
513	"di installazione. Una registrazione dinamica consiste in una serie di"
514	"pattern con cui vengono confrontati tutti i messaggi. Se un messaggio"
515	"corrisponde al pattern, il tool che ha registrato quel pattern"
516	"sarà candidato per riceverlo.."
517	""
518	"Per poter ricevere messaggi procedurali tramite ToolTalk, un processo"
519	"deve registrarsi con il message passer. Alla registrazione, il processo"
520	"specifica una serie di pattern a ToolTalk, il quale gli consegnerà i"
521	"messaggi corrispondenti. I pattern possono essere creati:"
522	""
523	"Staticamente, mediante un ptype. Un processo dichiara il suo ptype al"
524	"message passer; ToolTalk genera quindi i pattern da ogni firma del"
525	"ptype. Questi pattern possono essere modificati mediante l'ingresso e l'uscita"
526	"da sessioni e file, come nel passaggio dei messaggi orientati agli oggetti."
527	""
528	"Dinamicamente. Un processo crea i pattern \"sul momento\" e li registra"
529	"con ToolTalk. Un'applicazione tipica di questa funzione può essere un tool"
530	"di registrazione dei messaggi che osservi semplicemente tutti i messaggi"
531	"in transito e li visualizzi in una finestra; un tool di questo tipo"
532	"può essere utile nel debugging dei protocolli dei messaggi."
533	""
534	"Questa applicazione utilizza solo i pattern dinamici."
535	""
536	"Per registrare un pattern occorre: allocare un nuovo pattern, inserirvi"
537	"le informazioni appropriate e quindi registrarlo. Terminato l'uso del"
538	"pattern (quando cioè non si è più interessati ai messaggi corrispondenti"
539	"a quel pattern), liberare la memoria occupata."
540	""
541	"Per allocare il nuovo pattern, usare tt_pattern_create(), che restituirà"
542	"uno \"handle\" o \"puntatore opaco\"; questo handle dovrà essere usato"
543	"nelle chiamate successive per riferirsi a quel pattern."
544	""
545	"Per inserire le informazioni, usare le chiamate tt_pattern_*_add(); ne"
546	"esiste una per ogni attributo del pattern. È possibile indicare più"
547	"valori per ogni attributo; un attributo del pattern corrisponderà"
548	"a un attributo del messaggio quando uno qualsiasi dei valori"
549	"specificati nel pattern corrisponderà al valore del messaggio."
550	""
551	"Per gli attributi multipli, questa applicazione utilizza impostazioni"
552	"non esclusive e valori separati da virgole."
553	""
554	"Per individuare i messaggi di interesse indipendentemente dal valore di"
555	"un dato attributo, è sufficiente omettere tale attributo nel pattern."
556	""
557	"Se nel pattern non è specificato alcun attributo, ToolTalk considera"
558	"l'attributo del messaggio come corrispondente. Riducendo il numero di"
559	"attributi nel pattern si aumenta il numero dei messaggi ricevibili."
560	""
561	"Se nel pattern sono specificati più valori per un dato attributo, almeno"
562	"uno deve corrispondere al valore del messaggio. Se nessuno dei valori corri-"
563	"sponde, ToolTalk non considera l'applicazione come potenziale destinataria."
564	""
565	"Gli attributi Category e Scope devono sempre essere specificati."
566	""
567	"Quando il pattern è completo, registrarlo con tt_pattern_register()"
568	"e quindi unirsi alle sessioni o ai file richiesti selezionando"
569	"il pulsante Apply."
570	""
571	"Poiché i pattern registrati vengono aggiornati con l'unione a file e"
572	"sessioni, le registrazioni avvenute dopo un'unione non saranno incluse"
573	"nell'aggiornamento. Occorrerà perciò registrare tutti i pattern prima"
574	"dell'unione, oppure ripetere l'unione ogni volta che si registra un"
575	"nuovo pattern. Questo vale anche per i pattern registrati implicita-"
576	"mente con l'unione dei ptype."
577	"Address:"
578	"Poiché esistono molti tipi di tool, e gli utenti utilizzano tool diversi"
579	"in momenti diversi, è spesso impossibile per il mittente di un messaggio"
580	"identificare con precisione il suo destinatario. Perciò, il mittente assegna"
581	"al messaggio il nome di un'operazione che ne specifica il significato, ed"
582	"eventualmente indica un oggetto, o il tipo di oggetto (otype) a cui il"
583	"messaggio è diretto."
584	""
585	"Per i messaggi orientati agli oggetti, usare un oggetto o un otype. "
586	"Se l'indirizzo è uno handler, specificarne il nome."
587	""
588	"    TT_PROCEDURE: Op e Args specificati."
589	""
590	"    TT_OBJECT:    Object, Op e Args specificati."
591	""
592	"    TT_HANDLER:   Handler, Op e Args specificati."
593	""
594	"    TT_OTYPE:     Otype, Op e Args specificati."
595	"Object:"
596	"Specificare l'objid dell'oggetto a cui il messaggio deve essere inviato."
597	"OType:"
598	"Tipo dell'oggetto."
599	"Op:"
600	"Specificare l'operazione che descrive la notifica o la richiesta in"
601	"corso. Per determinare il nome dell'operazione, consultare la"
602	"definizione dell'otype dell'oggetto di destinazione."
603	"Scope:"
604	"La sessione scope viene usata per ricevere messaggi di altri"
605	"processi della stessa sessione; il file scope viene usato per"
606	"ricevere messaggi su un file."
607	""
608	"    TT_SESSION:          Riceve messaggi di altri processi della"
609	"                         sessione corrente."
610	""
611	"    TT_FILE:             Riceve messaggi sul file unito."
612	""
613	"    TT_BOTH:             Riceve messaggi su un file e sulla sessione."
614	""
615	"    TT_FILE_IN_SESSION:  Riceve messaggi per il file unito"
616	"                         mentre si trova nella sessione corrente."
617	"File:"
618	"Per uno scope di tipo file, specificare il nome del file."
619	"Sessione:"
620	"Per uno scope di tipo sessione, specificare il nome della sessione"
621	"(tt_default_session() è il valore predefinito)."
622	"Category:"
623	"Usare la categoria observe se si desidera soltanto osservare i messaggi; usare"
624	"la categoria handle per candidarsi come unico handler del messaggio."
625	""
626	"    TT_OBSERVE: I processi di osservazione ricevono solo copie del messaggio"
627	"                per informazione. Un messaggio può essere osservato da un"
628	"                numero qualsiasi di processi. I processi osservatori non possono"
629	"                mai restituire valori al mittente, neppure se il messaggio è una"
630	"                richiesta. In genere, le azioni degli osservatori hanno effetto solo"
631	"                sulla visualizzazione interattiva dei dati del tool sottostante."
632	""
633	"    TT_HANDLE:  I processi di gestione eseguono effettivamente un'azione basata"
634	"                sul messaggio. Un dato messaggio può essere gestito da un solo"
635	"                processo. Se il messaggio è una richiesta, il processo di gestione"
636	"                è quello che restituisce i valori richiesti. In genere, le azioni"
637	"                dei processi di gestione hanno effetto sulla rappresentazione"
638	"                dei dati del tool memorizzata in modo permanente."
639	"Class:"
640	"Usare la classe request per i messaggi che restituiscono un valore, o per i"
641	"quali si desidera un feedback che indichi se il messaggio viene gestito o è in coda,"
642	"o quando viene avviato un processo per gestire la richiesta. Usare la classe notice"
643	"per i messaggi che si limitano a notificare gli eventi ad altri processi."
644	""
645	"    TT_NOTICE:  Le notifiche sono messaggi che informano altri tool"
646	"                di un evento accaduto. I tool che inviano notifiche non"
647	"                attendono una risposta; il mittente desidera soltanto"
648	"                informare gli altri tool di quanto sta accadendo."
649	""
650	"    TT_REQUEST: Le richieste sono messaggi che chiedono a un altro tool di"
651	"                eseguire un'azione. Spesso, ma non sempre, il tool richiedente"
652	"                aspetta un valore di ritorno come risposta alla richiesta."
653	"                Anche se non viene restituito alcun valore, il tool che"
654	"                elabora la richiesta invia una risposta indicante il"
655	"                successo o meno dell'operazione."
656	"State:"
657	"Valori per l'attributo State di un messaggio. Qui di seguito sono elencati"
658	"i valori possibili e i relativi significati:"
659	""
660	"    TT_CREATED:  Il messaggio è stato creato ma non ancora inviato. Un messaggio"
661	"                 in questo stato può essere visto solo dal mittente."
662	""
663	"    TT_SENT:     Il messaggio è stato inviato ma non ancora gestito."
664	""
665	"    TT_HANDLED:  Il messaggio è stato gestito, i valori restituiti sono validi."
666	""
667	"    TT_FAILED:   Il messaggio non ha potuto essere consegnato a uno handler."
668	""
669	"    TT_QUEUED:   Il messaggio è stato messo in coda per la consegna in un momento successivo."
670	""
671	"    TT_STARTED:  Si cerca di avviare un processo in grado di gestire il messaggio."
672	""
673	"    TT_REJECTED: Il messaggio è stato respinto da un potenziale handler."
674	"                 Questo stato viene visto solo dal processo che rifiuta la "
675	"                 gestione; ToolTalk ripristina lo stato a TT_SENT e quindi"
676	"                 consegna il messaggio a un altro potenziale handler."
677	"Disposition:"
678	"Specifica l'azione da intraprendere se il messaggio non può essere gestito da"
679	"nessuno dei processi attivi. Queue indica che il messaggio deve essere collocato"
680	"in coda in attesa della registrazione di un processo dell'Handler_Ptype. Start "
681	"indica che occorre avviare un processo dell'Handler_Ptype."
682	""
683	"    TT_QUEUE: Il messaggio viene messo in coda in attesa di essere ricevuto"
684	"              da un processo del ptype appropriato."
685	""
686	"    TT_START: È in corso un tentativo di avviare un processo del ptype"
687	"              appropriato."
688	""
689	"Si noti che i valori di Tt_disposition possono essere sommati, per cui"
690	"TT_QUEUE+TT_START comprende sia il collocamento in coda del messaggio"
691	"che l'avvio del processo. Questo è utile nei casi in cui l'avvio possa"
692	"fallire (o essere bloccato dall'utente), per garantire che il messaggio"
693	"venga elaborato non appena si riesca ad avviare un processo adatto."
694	"Sender:"
695	"Identifica il processo che ha inviato il messaggio."
696	"Sender ptype:"
697	"È il ptype del processo che ha inviato il messaggio."
698	"Arguments:"
699	"Specificare gli argomenti specifici per l'operazione. Usare tt_message_arg_add"
700	"per aggiungere gli argomenti uno alla volta. Per ogni argomento è necessario"
701	"specificare: il modo (in, out o inout), il tipo e, se il modo è in o inout, il valore."
702	"Mode:"
703	"Specifica il modo di un argomento del messaggio. Qui di seguito sono"
704	"elencati i possibili valori e i relativi significati:"
705	""
706	"    TT_IN:    L'argomento viene scritto dal mittente e letto"
707	"              dallo handler e dagli eventuali osservatori."
708	""
709	"    TT_OUT:   L'argomento viene scritto dallo handler e letto dal"
710	"              mittente e da eventuali osservatori della risposta."
711	""
712	"    TT_INOUT: L'argomento viene scritto e letto dal mittente,"
713	"              dallo handler e da eventuali osservatori."
714	"Type:"
715	"Stringa indicante il tipo. I valori più usati sono \"string\" e \"int\","
716	"ma gli sviluppatori possono crearne di propri."
717	"Value:"
718	"Dati effettivi del valore, dipendenti dal tipo."
719	"Pulsante Add:"
720	"Aggiunge un argomento con i valori Mode, Type e Value specificati."
721	"Pulsante Delete:"
722	"Cancella l'argomento selezionato."
723	"Pulsante Change:"
724	"Modifica l'argomento selezionato impostando i valori correnti di Mode, Type"
725	"e Value."
726	"Pulsante Apply:"
727	"Registra il processo per ricevere i messaggi corrispondenti al pattern."
728	"Name:"
729	"Nome del contesto corrente"
730	"Value:"
731	"Valore appropriato per il tipo,"
732	""
733	"ad es. 55 per un tipo int, \"fred\" per un tipo char, o ^V^L^X per"
734	"un tipo byte."
735	"Add Context:"
736	"Aggiunge i valori correnti dei campi Name e Value alla lista"
737	"dei contesti."
738	"Delete Context:"
739	"Elimina l'elemento selezionato dalla lista dei contesti."
740	"Change Context:"
741	"Modifica l'elemento selezionato impostando il contenuto dei campi Name e Value."
742	"Edit Send Contexts:"
743	"Apre una finestra a scomparsa per modificare la lista dei contesti da inviare."
744	"Message"
745	"---------"
746	"Per inviare un messaggio: allocare un nuovo messaggio, inserirvi le informazioni"
747	"appropriate e quindi inviarlo. Le risposte compariranno nello stesso messaggio."
748	"Al termine, liberare la memoria occupata. (Per le richieste che restituiscono"
749	"un valore, liberare la memoria dopo aver copiato i valori di ritorno"
750	"richiesti; per le notifiche, procedere subito dopo l'invio),"
751	""
752	"Per allocare il nuovo messaggio, usare tt_message_create(), che restituirà"
753	"uno \"handle\" o \"puntatore opaco\"; questo handle dovrà essere usato"
754	"nelle chiamate successive per riferirsi a quel messaggio."
755	""
756	"Per inserire le informazioni, usare le chiamate tt_message_*_set();"
757	"ne esiste una per ogni attributo del messaggio."
758	""
759	"Impostare i campi Class, Address, Op e Arguments."
760	""
761	"Inviare il messaggio con tt_message_send()."
762	"Address:"
763	"Poiché esistono molti tipi di tool, e gli utenti utilizzano tool diversi"
764	"in momenti diversi, è spesso impossibile per il mittente di un messaggio"
765	"identificare con precisione il suo destinatario. Perciò, il mittente assegna"
766	"al messaggio il nome di un'operazione che ne specifica il significato, ed"
767	"eventualmente indica un oggetto o il tipo di oggetto (otype) a cui il"
768	"messaggio è diretto."
769	""
770	"Per i messaggi orientati agli oggetti, usare un oggetto o un otype. "
771	"Se l'indirizzo è uno handler, specificarne il nome."
772	""
773	"    TT_PROCEDURE: Op e Args specificati."
774	""
775	"    TT_OBJECT:    Object, Op e Args specificati."
776	""
777	"    TT_HANDLER:   Handler, Op e Args specificati."
778	""
779	"    TT_OTYPE:     Otype, Op e Args specificati."
780	"Handler:"
781	"Se si conosce il procid esatto dello handler, è possibile indirizzargli"
782	"i messaggi direttamente. Tipicamente, un processo effettua una richiesta"
783	"generale e quindi estrae l'attributo Handler dalla risposta, dirigendo"
784	"gli ulteriori messaggi allo stesso handler; questo consente a due"
785	"processi di incontrarsi attraverso il passaggio dei messaggi trasmessi"
786	"e di iniziare a dialogare."
787	"Handler_Ptype:"
788	"Se si conosce il ptype del processo che gestirà il messaggio, specificarlo."
789	"Il ptype è contenuto nella definizione del ptype che specifica"
790	"i particolari del protocollo."
791	"Object:"
792	"Specificare l'objid dell'oggetto a cui il messaggio deve essere inviato."
793	"OType:"
794	"Tipo dell'oggetto."
795	"Op:"
796	"Specificare l'operazione che descrive la notifica o la richiesta in"
797	"corso. Per determinare il nome dell'operazione, consultare la"
798	"definizione dell'otype dell'oggetto di destinazione."
799	"Scope:"
800	"Specificare sessione per ricevere messaggi di altri processi della"
801	"stessa sessione; specificare file per ricevere messaggi su un file."
802	""
803	""
804	"    TT_SESSION:          Riceve messaggi di altri processi della"
805	"                         sessione corrente."
806	""
807	"    TT_FILE:             Riceve messaggi sul file."
808	""
809	"    TT_BOTH:             Riceve messaggi sul file e sulla sessione."
810	""
811	"    TT_FILE_IN_SESSION:  Riceve messaggi per il file mentre"
812	"                         esso si trova nella sessione corrente."
813	"Session:"
814	"Specificare il nome della sessione (tt_default_session()"
815	"è il valore predefinito)."
816	"File:"
817	"Specificare il nome del file."
818	"Class:"
819	"Usare la classe request per i messaggi che restituiscono un valore, o per i"
820	"quali si desidera un feedback che indichi se il messaggio viene gestito o è in coda,"
821	"o quando viene avviato un processo per gestire la richiesta. Usare la classe notice"
822	"per i messaggi che si limitano a notificare gli eventi ad altri processi."
823	""
824	"    TT_NOTICE:  Le notifiche sono messaggi che informano altri tool di un"
825	"                evento accaduto. I tool che inviano notifiche non attendono"
826	"                una risposta; il mittente desidera soltanto informare"
827	"                gli altri tool di quanto sta accadendo."
828	""
829	"    TT_REQUEST: Le richieste sono messaggi che chiedono a un altro tool di"
830	"                eseguire un'azione. Spesso, ma non sempre, il tool richiedente"
831	"                aspetta un valore di ritorno come risposta alla richiesta."
832	"                Anche se non viene restituito alcun valore, il tool che"
833	"                elabora la richiesta invia una risposta indicante il successo"
834	"                o meno dell'operazione."
835	"Disposition:"
836	"Specifica l'azione da intraprendere se il messaggio non può essere gestito da"
837	"nessuno dei processi attivi. Queue indica che il messaggio deve essere collocato"
838	"in coda in attesa della registrazione di un processo dell'Handler_Ptype. Start"
839	"indica che occorre avviare un processo dell'Handler_Ptype."
840	""
841	"    TT_QUEUE: Il messaggio viene messo in coda in attesa di essere ricevuto"
842	"              da un processo del ptype appropriato."
843	""
844	"    TT_START: È in corso un tentativo di avviare un processo del ptype"
845	"              appropriato."
846	""
847	"Si noti che i valori di Tt_disposition possono essere sommati, per cui"
848	"TT_QUEUE+TT_START comprende sia il collocamento in coda del messaggio che"
849	"l'avvio del processo. Questo è utile nei casi in cui l'avvio possa fallire"
850	"(o essere bloccato dall'utente), per garantire che il messaggio venga"
851	"elaborato non appena si riesca ad avviare un processo adatto."
852	"Sender_Ptype:"
853	"È il ptype del processo che ha inviato il messaggio."
854	"Status:"
855	"Numero unico indicante i risultati della risposta al messaggio."
856	"Il numero deve essere maggiore di TT_ERR_LAST (2047)."
857	"Stringa Status:"
858	"Descrizione in formato testo dello stato del messaggio."
859	"Arguments:"
860	"Specificare gli argomenti specifici per l'operazione. Usare tt_message_arg_add"
861	"per aggiungere gli argomenti uno alla volta. Per ogni argomento è necessario"
862	"specificare: il modo (in, out o inout), il tipo e, se il modo è in o inout,"
863	"il valore."
864	"Mode:"
865	"Specifica il modo di un argomento del messaggio. Qui di seguito sono"
866	"elencati i possibili valori e i relativi significati:"
867	""
868	"    TT_IN:    L'argomento viene scritto dal mittente e letto"
869	"              dallo handler e dagli eventuali osservatori."
870	""
871	"    TT_OUT:   L'argomento viene scritto dallo handler e letto dal"
872	"              mittente e da eventuali osservatori della risposta."
873	""
874	"    TT_INOUT: L'argomento viene scritto e letto dal mittente,"
875	"              dallo handler e da eventuali osservatori."
876	"Type:"
877	"Stringa indicante il tipo. I valori più usati sono \"string\" e \"int\""
878	"ma gli sviluppatori possono crearne di propri."
879	"Value:"
880	"Dati effettivi del valore, dipendenti dal tipo."
881	"Pulsante Add:"
882	"Aggiunge un argomento con i valori Mode, Type e Value specificati."
883	"Pulsante Delete:"
884	"Cancella l'argomento selezionato."
885	"Pulsante Change:"
886	"Modifica l'argomento selezionato impostando i valori correnti di Mode,"
887	"Type e Value."
888	"Pulsante Send Message:"
889	"Invia il messaggio corrente. Stampa inoltre nell'output standard le chiamate"
890	"Tooltalk che verranno effettuate per creare e inviare il messaggio."
891	"Name:"
892	"Nome del contesto corrente."
893	"Value:"
894	"Valore del contesto corrente, interpretato come tipo."
895	"Add:"
896	"Aggiunge i valori dei campi di testo come nuovo contesto."
897	"Delete:"
898	"Cancella il contesto correntemente selezionato."
899	"Change:"
900	"Modifica il contesto selezionato in modo che rifletta il contenuto"
901	"corrente dei campi di testo."
902	"Impossibile aprire una pipe per l'output sieve.\n"
903	"Tts_string_list:generate è stato chiamato per un messaggio - comando ignorato \n"
$set 11
2	"TT_OK\tRichiesta eseguita."
3	"TT_WRN_NOTFOUND\tL'oggetto non è stato trovato - cancellazione non eseguita."
4	"TT_WRN_STALE_OBJID\tL'attributo dell'oggetto nel messaggio è stato sostituito con \
uno più recente. Aggiornare il punto da cui è stato ottenuto l'id dell'oggetto."
5	"TT_WRN_STOPPED\tL'interrogazione è stata interrotta dalla procedura di filtro."
6	"TT_WRN_SAME_OBJID\tL'oggetto spostato conserva lo stesso objid."
7	"TT_WRN_START_MESSAGE\tQuesto messaggio ha provocato l'avvio di questo processo.\
  È necessario rispondere a questo messaggio, anche se è una notifica."
8	"TT_WRN_APPFIRST\tQuesto codice non dovrebbe essere utilizzato."
9	"TT_WRN_LAST\tQuesto codice non dovrebbe essere utilizzato."
10	"TT_ERR_CLASS\tIl valore Tt_class specificato non è valido."
11	"TT_ERR_DBAVAIL\tDatabase necessario non disponibile. È possibile \
che l'indisponibilità sia temporanea, riprovare più tardi."
12	"TT_ERR_DBEXIST\tDatabase necessario non trovato. I database necessari \
devono essere creati prima di eseguire le azioni."
13	"TT_ERR_FILE\tImpossibile trovare l'oggetto file."
14	"TT_ERR_MODE\tIl valore Tt_mode non è valido."
15	"TT_ERR_ACCESS\tSi è cercato di accedere a un oggetto ToolTalk \
in un modo proibito dal sistema di protezione."
16	"TT_ERR_NOMP\tNessun processo ttsession in esecuzione, probabilmente tt_open() non è stato ancora chiamato. Se questo codice è stato restituito da tt_open(), significa che non è stato possibile eseguire ttsession. In genere, questo indica che ToolTalk non è installato sul sistema."
17	"TT_ERR_NOTHANDLER\tSolo lo handler del messaggio può eseguire questa operazione."
18	"TT_ERR_NUM\tIl valore intero specificato non è ammesso."
19	"TT_ERR_OBJID\tL'id dell'oggetto non si riferisce ad alcun oggetto esistente."
20	"TT_ERR_OP\tIl nome dell'operazione non è corretto sintatticamente."
21	"TT_ERR_OTYPE\tIl tipo di oggetto specificato non è installato."
22	"TT_ERR_ADDRESS\tIl valore Tt_address specificato non è valido."
23	"TT_ERR_PATH\tUna delle directory nel percorso non esiste o non è leggibile."
24	"TT_ERR_POINTER\tIl puntatore opaco (handler) specificato non indica un oggetto del tipo appropriato."
25	"TT_ERR_PROCID\tL'id del processo non è valido."
26	"TT_ERR_PROPLEN\tIl valore della caratteristica è troppo lungo."
27	"TT_ERR_PROPNAME\tIl nome della caratteristica non è corretto sintatticamente."
28	"TT_ERR_PTYPE\tIl tipo di processo specificato non è installato."
29	"TT_ERR_DISPOSITION\tIl valore Tt_disposition specificato non è valido."
30	"TT_ERR_SCOPE\tIl valore Tt_scope specificato non è valido."
31	"TT_ERR_SESSION\tL'id della sessione non corrisponde a una sessione attiva."
32	"TT_ERR_VTYPE\tIl tipo di valore specificato non è valido."
33	"TT_ERR_NO_VALUE\tNon esiste nessun valore di caratteristica con il nome e il numero specificati."
34	"TT_ERR_INTERNAL\tErrore interno (bug)"
35	"TT_ERR_READONLY\tImpossibile cambiare l'attributo."
36	"TT_ERR_NO_MATCH\tNon è stato trovato uno handler per questo messaggio, e la disposizione era diversa da queue o start."
37	"TT_ERR_UNIMP\tFunzione non implementata."
38	"TT_ERR_OVERFLOW\tTroppi messaggi attivi (riprovare più tardi)."
39	"TT_ERR_PTYPE_START\tIl tentativo di lanciare un'istanza di ptype non è riuscito."
40	"TT_ERR_CATEGORY\tL'oggetto pattern non ha nessuna categoria impostata."
41	"TT_ERR_DBUPDATE\tIl database non è coerente: un altro processo tt_spec_write ha aggiornato l'oggetto per primo."
42	"TT_ERR_DBFULL\tIl database Tooltalk è pieno."
43	"TT_ERR_DBCONSIST\tIl database è danneggiato o le informazioni di accesso sono incomplete (eseguire ttdbck)."
44	"TT_ERR_STATE\tTt_message ha un Tt_state non valido per l'operazione tentata."
45	"TT_ERR_NOMEM\tMemoria insufficiente."
46	"TT_ERR_SLOTNAME\tIl nome dello slot non è corretto sintatticamente."
47	"TT_ERR_XDR\tLa procedura XDR ha una lunghezza zero o è fallita durante l'avvio."
48	"TT_ERR_NETFILE\tIl nome del file di rete non è corretto sintatticamente."
49	"TT_DESKTOP_UNMODIFIED\tL'operazione non può essere eseguita con entità non modificate."
50	"TT_MEDIA_ERR_SIZE\tLa dimensione specificata era troppo grande o troppo piccola."
51	"TT_MEDIA_ERR_FORMAT\tI dati non corrispondono al formato previsto."
52	"TT_ERR_APPFIRST\tQuesto codice non dovrebbe essere utilizzato."
53	"TT_ERR_LAST\tQuesto codice non dovrebbe essere utilizzato."
54	"TT_STATUS_LAST\tQuesto codice non dovrebbe essere utilizzato."
55	"Tt_status sconosciuto."
56	"TT_DESKTOP_EPERM\tÈ necessario essere superutente"
57	"TT_DESKTOP_ENOENT\tFile o directory non trovati"
58	"TT_DESKTOP_EINTR\tChiamata di sistema interrotta"
59	"TT_DESKTOP_EIO\tErrore I/O"
60	"TT_DESKTOP_EAGAIN\tProcessi esauriti"
61	"TT_DESKTOP_ENOMEM\tSpazio insufficiente"
62	"TT_DESKTOP_EACCES\tAutorizzazione negata"
63	"TT_DESKTOP_EFAULT\tIndirizzo errato"
64	"TT_DESKTOP_EEXIST\tIl file esiste già"
65	"TT_DESKTOP_ENODEV\tDispositivo non trovato"
66	"TT_DESKTOP_ENOTDIR\tNon è una directory"
67	"TT_DESKTOP_EISDIR\tÈ una directory"
68	"TT_DESKTOP_EINVAL\tArgomento non valido"
69	"TT_DESKTOP_ENFILE\tOverflow della tabella file"
70	"TT_DESKTOP_EMFILE\tTroppi file aperti"
71	"TT_DESKTOP_ETXTBSY\tIl file di testo è occupato"
72	"TT_DESKTOP_EFBIG\tIl file è troppo grande"
73	"TT_DESKTOP_ENOSPC\tSpazio insufficiente sull'unità"
74	"TT_DESKTOP_EROFS\tIl file system è di sola lettura"
75	"TT_DESKTOP_EMLINK\tTroppi collegamenti"
76	"TT_DESKTOP_EPIPE\tPipe interrotta"
77	"TT_DESKTOP_ENOMSG\tNessun messaggio del tipo desiderato"
78	"TT_DESKTOP_EDEADLK\tCondizione di deadlock"
79	"TT_DESKTOP_ENODATA\tNessun dato disponibile"
80	"TT_DESKTOP_EPROTO\tErrore di protocollo"
81	"TT_DESKTOP_ENOTEMPTY\tLa directory non è vuota"
82	"TT_DESKTOP_ETIMEDOUT\tTempo scaduto per il collegamento"
83	"TT_DESKTOP_EALREADY\tL'operazione è già in corso"
84	"TT_DESKTOP_ECANCELED\tOperazione annullata"
85	"TT_DESKTOP_ENOTSUP\tNon supportato"
86	"TT_ERR_TOOLATE\tThis must be the first call made into the ToolTalk API and can therefore no longer be performed."
87	"TT_ERR_AUTHORIZATION\tThe user is not authorized to connect to this ToolTalk session."
88	"TT_AUTHFILE_ACCESS\tThe user is not authorized to access the ToolTalk authority file."
89	"TT_AUTHFILE_LOCK\tCannot lock the ToolTalk authority file."
90	"TT_AUTHFILE_LOCK_TIMEOUT\tCannot lock the ToolTalk authority file."
91	"TT_AUTHFILE_UNLOCK\tCannot unlock the ToolTalk authority file."
92	"TT_AUTHFILE_MISSING\tThe ToolTalk authority file is missing."
93	"TT_AUTHFILE_ENTRY_MISSING\tThe ToolTalk authority file is missing an entry for this session."
94	"TT_AUTHFILE_WRITE\tCannot write the ToolTalk authority file."
95	"TT_ERR_VERSION_MISMATCH\tThis client is using a different RPC or program version from the server of this ToolTalk session."
